import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.DnwzncJk.js";const l="/images/note-scoped1.png",c=JSON.parse('{"title":"<style>中的scoped原理","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"src/note/points/style中的scope原理.md","filePath":"src/note/points/style中的scope原理.md","lastUpdated":1754387755000}'),p={name:"src/note/points/style中的scope原理.md"};function e(h,s,k,d,E,o){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="style-中的scoped原理" tabindex="-1"><code>&lt;style&gt;</code>中的<code>scoped</code>原理 <a class="header-anchor" href="#style-中的scoped原理" aria-label="Permalink to &quot;\`&lt;style&gt;\`中的\`scoped\`原理&quot;">​</a></h1><p>Vue <code>&lt;style&gt;</code> 中的 <code>scoped</code> 有什么作用吗</p><h2 id="_1、认识-style-中的-scoped" tabindex="-1">1、认识<code>&lt;style&gt;</code> 中的 <code>scoped</code> <a class="header-anchor" href="#_1、认识-style-中的-scoped" aria-label="Permalink to &quot;1、认识\`&lt;style&gt;\` 中的 \`scoped\`&quot;">​</a></h2><p>我们在写样式的时候，经常会遇到一个习惯，就是在style样式之中加一个scoped达到css局部作用域的作用，那么，你了解过这个 <code>scoped</code> 属性吗</p><p>实际使用之中限制局部样式</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="_2、-style-中的-scoped原理" tabindex="-1">2、<code>&lt;style&gt;</code> 中的 <code>scoped</code>原理 <a class="header-anchor" href="#_2、-style-中的-scoped原理" aria-label="Permalink to &quot;2、\`&lt;style&gt;\` 中的 \`scoped\`原理&quot;">​</a></h2><p>我们先来简单看看这个<code>scoped</code> 属性是如何实现在加入css之中影响当前的vue组件的</p><p>当一个style标签拥有scoped属性时候，css样式只能用于当前的Vue组件,原理是通过PostCSS来实现，通过给想对应的dom新增一个属性，同时给css选择器新增一个对应的属性，来对应这个唯一的dom，如下所示,我们可以看看具体转译。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//编译前</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;example&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Scoped style example</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.example {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  color: red;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编译后</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.example[data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xxxx] {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: red;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>PostCSS简单介绍</p><p>PostCSS 是一个用于处理 CSS 的工具，它可以将 CSS 转换为不同的格式或应用特定的插件来增强 CSS 功能。它允许你使用各种插件，例如自动添加浏览器前缀、支持最新的 CSS 语法、优化 CSS 文件大小等。通过配置 <code>postcss.config.js</code> 文件，你可以定制它的行为以适应项目的需求。</p></blockquote><p><code>&lt;style scoped&gt;</code> 可能实现的原理略微不同，有以下几种：</p><ol><li><strong>CSS 属性选择器</strong>： 在 Vue.js 中，<code>scoped</code> 属性通过给组件的根元素添加一个唯一的属性（如 <code>data-v-xxxx</code>），然后将 CSS 选择器调整为匹配这些唯一属性。Vue.js 会将 <code>&lt;style scoped&gt;</code> 中的 CSS 转换为类似 <code>div[data-v-xxxx] .my-class</code> 的选择器，这样 CSS 规则只应用于包含该属性的元素。</li><li><strong>CSS 模块</strong>： 一些工具和框架（如 React 的 CSS 模块）通过将 CSS 类名自动生成唯一标识符来实现作用域隔离，意味着组件中的 CSS 类名被转换为独特的名称，从而避免样式冲突。</li><li><strong>Shadow DOM</strong>： Web Components 标准的 Shadow DOM 允许将样式和结构封装在一个组件的私有 DOM 中，从而实现样式的隔离。虽然 <code>scoped</code> 属性与 Shadow DOM 并不直接相关，但它们都旨在实现局部样式作用域。</li></ol><h2 id="_3、-style-中的-scoped优点和缺点" tabindex="-1">3、<code>&lt;style&gt;</code> 中的 <code>scoped</code>优点和缺点： <a class="header-anchor" href="#_3、-style-中的-scoped优点和缺点" aria-label="Permalink to &quot;3、\`&lt;style&gt;\` 中的 \`scoped\`优点和缺点：&quot;">​</a></h2><p>他能起到的作用也非常明显：</p><h3 id="优点" tabindex="-1">优点： <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点：&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 限制组件样式当前作用域</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 控制子组件根节点样式</span></span></code></pre></div><h3 id="缺点" tabindex="-1">缺点： <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点：&quot;">​</a></h3><p>但是它的缺点你却可能有些忽略（这里其实一开始我也忽略了）</p><h4 id="⭐子组件样式想在父组件之中干涉必须强制" tabindex="-1">⭐子组件样式想在父组件之中干涉必须强制 <a class="header-anchor" href="#⭐子组件样式想在父组件之中干涉必须强制" aria-label="Permalink to &quot;⭐子组件样式想在父组件之中干涉必须强制&quot;">​</a></h4><p>这个其实就是只能强制去进行更改子组件的样式，例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">deep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>也就是必须通过下面的干涉才能生效css样式</p><p><img src="`+l+`" alt="image.png" loading="lazy"></p><h4 id="⭐性能问题" tabindex="-1">⭐性能问题 <a class="header-anchor" href="#⭐性能问题" aria-label="Permalink to &quot;⭐性能问题&quot;">​</a></h4><p>使用scoped这个会造成你浏览器性能消耗</p><p><code>没错，使用scoped这个是会造成你浏览器性能消耗的!!!!!</code></p><p>因为浏览器在渲染时需要额外的步骤来查找和匹配这些唯一的属性选择器。具体来说，使用 <code>scoped</code> 属性时，框架（如 Vue.js）会为每个组件生成独特的属性选择器，这会增加浏览器的计算负担，尤其是在包含大量组件或复杂样式的应用中。每次渲染时，浏览器需要检查这些属性选择器并应用相应的样式，这可能导致额外的开销，尤其在大规模应用或复杂的样式层级中。</p><p>在实践中，这种性能影响通常较小，但在极端情况下或对于性能要求极高的应用，可能需要注意优化和性能测试。</p><p>所以，其实我加个类名的事，所以我尽量减少它的使用！</p><h2 id="_4、类似实现" tabindex="-1">4、类似实现 <a class="header-anchor" href="#_4、类似实现" aria-label="Permalink to &quot;4、类似实现&quot;">​</a></h2><p>除了 <code>&lt;style scoped&gt;</code> 之外，类似用于实现 CSS 的局部作用域或样式隔离，以避免样式冲突和提高组件化开发的灵活性方法和技术还有几种：</p><h3 id="_1-css-模块-css-modules" tabindex="-1">（1） <strong>CSS 模块（CSS Modules）</strong> <a class="header-anchor" href="#_1-css-模块-css-modules" aria-label="Permalink to &quot;（1） **CSS 模块（CSS Modules）**&quot;">​</a></h3><p><strong>概念</strong>：CSS 模块通过为每个 CSS 类名生成唯一的标识符来实现局部作用域，避免类名冲突。</p><p><strong>实现</strong>：在构建过程中，工具（如 Webpack、Vite）会自动为每个类名生成唯一的哈希值，从而避免全局样式冲突。</p><p>下面是<strong>示例</strong>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* styles.module.css */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.example {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: red;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Component.jsx</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> styles </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./styles.module.css&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{styles.example}&gt;CSS Modules example&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_2-css-in-js" tabindex="-1">（2）<strong>CSS-in-JS</strong> <a class="header-anchor" href="#_2-css-in-js" aria-label="Permalink to &quot;（2）**CSS-in-JS**&quot;">​</a></h3><p><strong>概念</strong>：CSS-in-JS 是一种在 JavaScript 文件中编写和管理 CSS 的技术，使样式与组件逻辑紧密结合，通常会生成唯一类名避免冲突。</p><p><strong>实现</strong>：使用类似 styled-components 或 Emotion 的库，可以在组件中直接编写样式，库会处理样式的局部作用域和唯一性。</p><p>下面是<strong>示例</strong>：（使用 styled-components）：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> styled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;styled-components&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Example</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> styled.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">div</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  color: red;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;CSS-in-JS example&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3-shadow-dom" tabindex="-1">（3） <strong>Shadow DOM</strong> <a class="header-anchor" href="#_3-shadow-dom" aria-label="Permalink to &quot;（3） **Shadow DOM**&quot;">​</a></h3><p><strong>概念</strong>：Shadow DOM 是 Web Components 的一部分，允许将样式和 DOM 结构封装在组件内部，实现样式完全隔离。</p><p><strong>实现</strong>：浏览器会为 Shadow DOM 中的样式创建独立的作用域，外部样式和内部样式不会相互影响。</p><p>下面是<strong>示例</strong>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">html</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my-component&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .example {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      color: red;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;example&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Shadow DOM example&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  class MyComponent extends HTMLElement {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      const template </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-component&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).content.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cloneNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      const shadowRoot </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">attachShadow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;open&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      shadowRoot.appendChild(template);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  customElements.define(&#39;my-component&#39;, MyComponent);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">my-component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">my-component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="_4-bem-块、元素、修饰符" tabindex="-1">（4） <strong>BEM（块、元素、修饰符）</strong> <a class="header-anchor" href="#_4-bem-块、元素、修饰符" aria-label="Permalink to &quot;（4） **BEM（块、元素、修饰符）**&quot;">​</a></h3><p><strong>概念</strong>：BEM 是一种 CSS 命名约定，用于创建可复用的组件并避免样式冲突。虽然 BEM 本身不提供局部作用域，但它通过命名规则减少了样式冲突的可能性。</p><p><strong>实现</strong>：使用特定的命名模式，如 <code>block__element--modifier</code>，可以帮助确保样式的唯一性和可维护性。</p><p><strong>示例</strong>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">css</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* BEM 命名规范 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.button {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: red;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.button</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">primary {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  background</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: blue;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">html</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;button button--primary&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;BEM example&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="_5-前缀化-prefixing" tabindex="-1">（5） <strong>前缀化（Prefixing）</strong> <a class="header-anchor" href="#_5-前缀化-prefixing" aria-label="Permalink to &quot;（5） **前缀化（Prefixing）**&quot;">​</a></h3><p><strong>概念</strong>：通过在 CSS 规则中添加特定的前缀，可以帮助确保样式的作用范围仅限于特定的组件或部分。</p><p><strong>实现</strong>：可以手动或通过工具（如 PostCSS 插件）为 CSS 类名添加前缀。</p><p><strong>示例</strong>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">css</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 带有前缀的样式 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.component</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">button {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: red;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;component-button&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Prefixing example&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div>`,60)]))}const g=i(p,[["render",e]]);export{c as __pageData,g as default};
