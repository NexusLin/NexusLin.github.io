import{_ as s,c as a,o as e,a4 as n}from"./chunks/framework.p1nTaqAP.js";const p="/NexusLin/images/node2-1.png",m=JSON.parse('{"title":"❤Node02-Nodejs环境安装和依赖使用","description":"","frontmatter":{},"headers":[],"relativePath":"src/Node/Node02-Nodejs环境安装和依赖配置初.md","filePath":"src/Node/Node02-Nodejs环境安装和依赖配置初.md"}'),o={name:"src/Node/Node02-Nodejs环境安装和依赖配置初.md"},t=n(`<h1 id="❤node02-nodejs环境安装和依赖使用" tabindex="-1">❤Node02-Nodejs环境安装和依赖使用 <a class="header-anchor" href="#❤node02-nodejs环境安装和依赖使用" aria-label="Permalink to &quot;❤Node02-Nodejs环境安装和依赖使用&quot;">​</a></h1><h2 id="_1、环境检查" tabindex="-1">1、环境检查 <a class="header-anchor" href="#_1、环境检查" aria-label="Permalink to &quot;1、环境检查&quot;">​</a></h2><p>先来查看一下本地版本</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jsnode -v</span></span>
<span class="line"><span>npm -v</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jsv20.12.0 //node版本</span></span>
<span class="line"><span>10.5.0 //npm版本</span></span></code></pre></div><p><img src="`+p+`" alt="image.png"></p><h2 id="_2、项目搭建" tabindex="-1">2、项目搭建 <a class="header-anchor" href="#_2、项目搭建" aria-label="Permalink to &quot;2、项目搭建&quot;">​</a></h2><p>找一个空包的文件夹，英文命名</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jsmkdir Nexusapi //创建文件夹</span></span>
<span class="line"><span>cd Nexusapi</span></span>
<span class="line"><span>yarn init</span></span></code></pre></div><p>这个时候我们Nexusapi文件夹下已经生成了package.json项目配置,这个时候的文档目录结构就成为了</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Nexusapi</span></span>
<span class="line"><span>├── node_modules</span></span>
<span class="line"><span>├── package.json</span></span>
<span class="line"><span>└── yarn.lock</span></span></code></pre></div><h2 id="_3、安装我们的核心依赖" tabindex="-1">3、安装我们的核心依赖 <a class="header-anchor" href="#_3、安装我们的核心依赖" aria-label="Permalink to &quot;3、安装我们的核心依赖&quot;">​</a></h2><h3 id="_1-安装express" tabindex="-1">（1）安装express <a class="header-anchor" href="#_1-安装express" aria-label="Permalink to &quot;（1）安装express&quot;">​</a></h3><p>Express 是一个流行的 Node.js Web 应用程序框架，用来给砸门的项目来构建后台接口 用于构建 Rest API 帮助前后端实现通讯</p><h3 id="_2-mysql-数据库" tabindex="-1">（2）MySQL 数据库 <a class="header-anchor" href="#_2-mysql-数据库" aria-label="Permalink to &quot;（2）MySQL 数据库&quot;">​</a></h3><p>Node.js 中连接 MySQL 数据库并编写后台接口，需要安装mysql依赖： <strong>mysql</strong>: 是一个 MySQL 客户端库，用于在 Node.js 中连接和操作 MySQL 数据库。你可以使用它执行 SQL 查询、插入、更新、删除等操作。</p><h3 id="_3-cors-跨域使用" tabindex="-1">（3）<strong>cors</strong> 跨域使用 <a class="header-anchor" href="#_3-cors-跨域使用" aria-label="Permalink to &quot;（3）**cors** 跨域使用&quot;">​</a></h3><p>cors 提供 Express 中间件 CORS（跨源资源共享）是一种安全机制，用于控制在不同源之间的资源共享。当你在使用 Node.js 构建服务器时，可能会遇到跨域资源访问的问题，特别是在处理前端应用程序向服务器发送的 AJAX 请求时。</p><h3 id="_1-cors-处理接口跨域" tabindex="-1">（1）cors(处理接口跨域) <a class="header-anchor" href="#_1-cors-处理接口跨域" aria-label="Permalink to &quot;（1）cors(处理接口跨域)&quot;">​</a></h3><p>下载cors，用于处理接口跨域问题</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jsyarn add cors //安装cors</span></span>
<span class="line"><span>import cors from &#39;cors&#39; //引入</span></span>
<span class="line"><span>app.use(cors());//使用</span></span></code></pre></div><h3 id="_2-cors-处理编码数据" tabindex="-1">（2）cors (处理编码数据) <a class="header-anchor" href="#_2-cors-处理编码数据" aria-label="Permalink to &quot;（2）cors (处理编码数据)&quot;">​</a></h3><ul><li><strong>body-parser</strong> - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。</li><li><strong>cookie-parser</strong> - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。</li><li><strong>multer</strong> - node.js 中间件，用于处理 enctype=&quot;multipart/form-data&quot;（设置表单的MIME编码）的表单数据。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>js$ yarn add  body-parser --save</span></span>
<span class="line"><span>$ yarn add  cookie-parser --save</span></span>
<span class="line"><span>$ yarn add  multer --save</span></span></code></pre></div><p>app.js之中我们对数据进行优化处理</p><h4 id="引入" tabindex="-1">引入: <a class="header-anchor" href="#引入" aria-label="Permalink to &quot;引入:&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jsimport express from &#39;express&#39;</span></span>
<span class="line"><span>import cors from &#39;cors&#39;</span></span>
<span class="line"><span>import bodyParser from &#39;body-parser&#39;</span></span></code></pre></div><h4 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>js</span></span>
<span class="line"><span>const app = express();</span></span>
<span class="line"><span>app.use(express.json()); // 中间件，用于解析 POST 请求体中的 JSON 数据</span></span>
<span class="line"><span>app.use(cors());</span></span>
<span class="line"><span>app.use(bodyParser.json());  //配置解析，用于解析json和urlencoded格式的数据</span></span>
<span class="line"><span>app.use(bodyParser.urlencoded({extended: false}));</span></span></code></pre></div><h3 id="_4-body-parser-可选" tabindex="-1">（4）<strong>body-parser</strong>（可选） <a class="header-anchor" href="#_4-body-parser-可选" aria-label="Permalink to &quot;（4）**body-parser**（可选）&quot;">​</a></h3><p>body-parser 中间件用来解析POST 请求中的数据，解析请求体中的 JSON 数据或表单数据，使用 body-parser 中间件来实现。在最新版本的 Express 中，<code>express.json()</code> 和 <code>express.urlencoded()</code> 替代了 body-parser。 换句话说 req.body 对象 就是它提供的</p><h3 id="_5-express-jwt" tabindex="-1">（5）<strong>express-jwt</strong> <a class="header-anchor" href="#_5-express-jwt" aria-label="Permalink to &quot;（5）**express-jwt**&quot;">​</a></h3><p>Express-jwt 是一个用于验证 JSON Web Tokens（JWT）的 Express 中间件。它使得在 Express 应用程序中验证 token 变得简单。</p><h3 id="_6-jsonwebtoken" tabindex="-1">（6）<strong>jsonwebtoken</strong> <a class="header-anchor" href="#_6-jsonwebtoken" aria-label="Permalink to &quot;（6）**jsonwebtoken**&quot;">​</a></h3><p>JSON Web Token（JWT）是一种用于安全传输信息的开放标准（RFC 7519）。在 Node.js 中，你可以使用 <code>jsonwebtoken</code> 模块来生成、解析和验证 JWT。以下是在 Node.js 中使用 <code>jsonwebtoken</code> 的基本步骤：</p><h3 id="_7-multer" tabindex="-1">（7）<strong>multer</strong> <a class="header-anchor" href="#_7-multer" aria-label="Permalink to &quot;（7）**multer**&quot;">​</a></h3><p><code>multer</code> 是一个中间件，专门用于处理 <code>multipart/form-data</code> 类型的数据，主要用于上传文件。这种类型的数据主要用在表单中，特别是用于上传文件到服务器。</p><h3 id="_8-ws模块" tabindex="-1">（8） ws模块 <a class="header-anchor" href="#_8-ws模块" aria-label="Permalink to &quot;（8） ws模块&quot;">​</a></h3><p>ws是易于使用的 WebSocket 客户端和服务器库，<code>ws</code> 模块为 Node.js 提供了一个便捷的方式来实现 WebSocket 功能，使得开发者可以轻松地构建支持实时双向通信的 Web 应用程序。WebSocket 是一种在 Web 应用程序中实现实时双向通信的协议，它允许服务器和客户端之间建立持久连接，以便实时地传输数据。 <code>ws</code> 模块的主要作用包括：</p><ol><li><strong>WebSocket 服务器端实现</strong>：<code>ws</code> 模块允许你在 Node.js 中轻松创建 WebSocket 服务器，从而使你的应用程序能够接受和处理来自客户端的 WebSocket 连接。</li><li><strong>WebSocket 客户端实现</strong>：除了服务器端实现外，<code>ws</code> 模块还提供了 WebSocket 客户端功能，使得你可以在 Node.js 中编写客户端代码来连接到 WebSocket 服务器，并与之进行双向通信。</li><li><strong>简单易用</strong>：<code>ws</code> 模块设计简单，易于使用，提供了一组直观的 API，使得创建 WebSocket 服务器和客户端变得非常容易。</li><li><strong>高性能</strong>：<code>ws</code> 模块具有良好的性能，适用于处理大量的 WebSocket 连接，并且可以有效地处理实时数据传输。</li></ol><h3 id="_9-dotenv-可选-未使用" tabindex="-1">（9）<strong>dotenv</strong>（可选-未使用） <a class="header-anchor" href="#_9-dotenv-可选-未使用" aria-label="Permalink to &quot;（9）**dotenv**（可选-未使用）&quot;">​</a></h3><p>从环境变量中读取敏感信息，比如数据库连接信息，你可以使用 dotenv 模块。它允许你将这些信息存储在一个名为 <code>.env</code> 的文件中，并在应用程序中使用 <code>process.env</code> 来访问它们。</p><h3 id="_10-ejs模块-可选" tabindex="-1">（10） ejs模块（可选） <a class="header-anchor" href="#_10-ejs模块-可选" aria-label="Permalink to &quot;（10） ejs模块（可选）&quot;">​</a></h3><ol><li><strong>ejs</strong>（可选）可以在服务器端渲染聊天页面，你可以选择使用 ejs 或其他模板引擎。</li></ol><h3 id="_11-nodemon使用-可选" tabindex="-1">（11） nodemon使用（可选） <a class="header-anchor" href="#_11-nodemon使用-可选" aria-label="Permalink to &quot;（11） nodemon使用（可选）&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>js### 开发环境安装</span></span>
<span class="line"><span>npm install nodemon --save-dev</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### 全局安装</span></span>
<span class="line"><span>npm install -g nodemon</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### 验证安装成功没有</span></span>
<span class="line"><span>nodemon -v</span></span>
<span class="line"><span></span></span>
<span class="line"><span>### nodemon命令行参数配置帮助</span></span>
<span class="line"><span>nodemon --help</span></span></code></pre></div><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h3><ul><li><code>corsOptions</code> 这里设置了可访问后端的前端来源为 <code>*</code> ，这意味着任何前端都可以接入此后端。这样设置并不安全，为了避免「跨域问题」，先这么设置。之后请在这里限制可访问的前端服务器。</li></ul><h3 id="安装命令" tabindex="-1">安装命令 <a class="header-anchor" href="#安装命令" aria-label="Permalink to &quot;安装命令&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jsyarn add express   1</span></span>
<span class="line"><span>yarn add mysql     2</span></span>
<span class="line"><span>yarn add cors      3</span></span>
<span class="line"><span>yarn add body-parser  4</span></span>
<span class="line"><span>yarn add express-jwt  5</span></span>
<span class="line"><span>yarn add jsonwebtoken 6</span></span>
<span class="line"><span>yarn add multer 7</span></span>
<span class="line"><span>yarn add ws 8</span></span>
<span class="line"><span>yarn add dotenv (暂时不使用)</span></span>
<span class="line"><span>yarn add ejs  (暂时不使用)</span></span>
<span class="line"><span>yarn add nodemon --save-dev  (暂时不使用)</span></span></code></pre></div><p>4、启动 新建文件夹server，下面新建app.js文件，内容如下</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jsconsole.log(&#39;我是Nexusapi服务器端!&#39;);</span></span></code></pre></div><p>进入根目录下server文件以后cmd进行启动</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>jscd server</span></span>
<span class="line"><span>node app.js</span></span></code></pre></div><p>控制台可以输出</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>js我是Nexusapi服务器端!</span></span></code></pre></div><p>这个时候就证明砸门Node后台项目已经搭建好了。</p>`,57),l=[t];function i(d,r,c,h,b,u){return e(),a("div",null,l)}const k=s(o,[["render",i]]);export{m as __pageData,k as default};
