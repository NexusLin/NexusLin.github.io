import{_ as a,c as i,o as n,ag as p}from"./chunks/framework.DnwzncJk.js";const g=JSON.parse('{"title":"八大数据结构","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"src/algorithm/04-8大数据结构.md","filePath":"src/algorithm/04-8大数据结构.md","lastUpdated":1762423305000}'),l={name:"src/algorithm/04-8大数据结构.md"};function h(t,s,e,k,r,E){return n(),i("div",null,s[0]||(s[0]=[p(`<h1 id="八大数据结构" tabindex="-1">八大数据结构 <a class="header-anchor" href="#八大数据结构" aria-label="Permalink to &quot;八大数据结构&quot;">​</a></h1><ul><li>八大数据结构的JS实现</li></ul><h2 id="_1-栈-stack" tabindex="-1">1. 栈**（Stack）** <a class="header-anchor" href="#_1-栈-stack" aria-label="Permalink to &quot;1. 栈**（Stack）**&quot;">​</a></h2><h3 id="认识" tabindex="-1">认识 <a class="header-anchor" href="#认识" aria-label="Permalink to &quot;认识&quot;">​</a></h3><p><code>栈</code>是一个<strong>线性数据结构</strong>，遵循<strong>后进先出</strong>（LIFO，Last In First Out）的原则</p><p><code>JavaScript</code>中没有<code>栈</code>，但是可以用<code>Array</code>实现<code>栈</code>的所有功能。</p><p>JS实现</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 数组实现栈数据结构</span></span>
<span class="line"><span>const stack = []</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 入栈</span></span>
<span class="line"><span>stack.push(0)</span></span>
<span class="line"><span>stack.push(1)</span></span>
<span class="line"><span>stack.push(2)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 出栈</span></span>
<span class="line"><span>const popVal = stack.pop() // popVal 为 2</span></span></code></pre></div><p><strong>使用场景</strong></p><ul><li>场景一：十进制转二进制</li><li>场景二：有效括号</li><li>场景三：函数调用堆栈</li></ul><p><strong>LeetCode题目</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 有效括号</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">144</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 二叉树的前序遍历</span></span></code></pre></div><h3 id="特点" tabindex="-1"><strong>特点</strong> <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;**特点**&quot;">​</a></h3><ol><li><strong>后进先出</strong>：栈的操作遵循“后进先出”的规则。最新加入栈的元素会最先被移除。</li><li><strong>只能在一端操作</strong>：栈只有一个端口进行操作，通常是栈顶（Top），也叫栈顶操作。</li><li><strong>两种基本操作</strong>： <ul><li><strong>push</strong>：将元素压入栈中。</li><li><strong>pop</strong>：从栈顶弹出元素。</li></ul></li></ol><p>栈通常用于需要“撤回”或“回溯”的操作场景，例如：浏览器历史记录、撤销操作、递归的实现等。</p><h3 id="基本操作" tabindex="-1"><strong>基本操作</strong> <a class="header-anchor" href="#基本操作" aria-label="Permalink to &quot;**基本操作**&quot;">​</a></h3><ol><li><strong>push</strong>：将元素放入栈中。</li><li><strong>pop</strong>：将栈顶元素移除。</li><li><strong>peek/top</strong>：查看栈顶元素，但不移除。</li><li><strong>isEmpty</strong>：检查栈是否为空。</li><li><strong>size</strong>：获取栈的大小。</li></ol><h3 id="栈的实现" tabindex="-1"><strong>栈的实现</strong> <a class="header-anchor" href="#栈的实现" aria-label="Permalink to &quot;**栈的实现**&quot;">​</a></h3><p>在 JavaScript 中，我们可以通过数组来实现栈。数组本身提供了 <code>push()</code> 和 <code>pop()</code> 方法，可以直接用来模拟栈的行为。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Stack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 存储栈元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 压入元素</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 弹出栈顶元素</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;栈为空，无法弹出&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 查看栈顶元素</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;栈为空&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 判断栈是否为空</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取栈的大小</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用栈</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stack </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Stack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 压入元素 10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 压入元素 20</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出栈顶元素: 20</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 弹出栈顶元素: 20</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出栈的大小: 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出栈是否为空: false</span></span></code></pre></div><h3 id="使用场景" tabindex="-1"><strong>使用场景</strong> <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;**使用场景**&quot;">​</a></h3><p>栈的应用非常广泛，特别是在需要反向操作的场合。以下是一些常见的使用场景：</p><ol><li><strong>递归调用</strong>：递归在计算机内部通常是通过栈来实现的，栈保存了每一层函数的执行状态，调用栈的最后一个元素是当前正在执行的函数。</li><li><strong>表达式求值</strong>：栈常用于表达式的求值，如中缀表达式转后缀表达式（逆波兰表达式）时，或者是求解括号匹配的问题。</li><li><strong>浏览器历史记录</strong>：浏览器的“前进”和“后退”按钮实现的就是基于栈的。每当你访问一个新页面时，浏览器会将该页面推入栈中，当你点击“后退”时，栈顶的页面会被弹出。</li><li><strong>撤销操作</strong>：例如，在文本编辑器中，每当用户执行操作时，都会把这些操作压入栈中。如果用户点击撤销按钮，栈顶的操作就会被弹出，从而恢复之前的状态。</li><li><strong>括号匹配</strong>：在编程语言的语法分析中，检查括号是否匹配也是栈的一种应用。如果遇到左括号就压栈，遇到右括号就弹栈，最终栈是否为空来判断括号是否匹配。</li></ol><h3 id="栈的优缺点" tabindex="-1"><strong>栈的优缺点</strong> <a class="header-anchor" href="#栈的优缺点" aria-label="Permalink to &quot;**栈的优缺点**&quot;">​</a></h3><p><strong>优点</strong>：</p><ol><li><strong>操作简单</strong>：栈的操作非常简单，只涉及到压栈、弹栈和查看栈顶元素等基本操作。</li><li><strong>空间高效</strong>：栈是一个线性数据结构，使用数组或链表存储数据，不需要额外的空间开销。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>访问限制</strong>：栈只能通过栈顶进行访问，无法直接访问中间的元素，效率较低。</li><li><strong>溢出问题</strong>：如果栈的容量有限，当栈满时，再执行 <code>push()</code> 操作会导致栈溢出。</li></ol><h2 id="_2-队列" tabindex="-1">2. 队列 <a class="header-anchor" href="#_2-队列" aria-label="Permalink to &quot;2. 队列&quot;">​</a></h2><h4 id="认识-1" tabindex="-1">认识 <a class="header-anchor" href="#认识-1" aria-label="Permalink to &quot;认识&quot;">​</a></h4><p><strong>队列（Queue）</strong> 是一种 <strong>线性数据结构</strong>，遵循<strong>先进先出（FIFO, First-In-First-Out）</strong> 的原则。</p><p>也就是说，队列中的元素按照它们被加入的顺序排列，先加入队列的元素先被移除，后加入队列的元素后被移除。</p><p><code>JavaScript</code>中没有<code>队列</code>，但是可以用<code>Array</code>实现<code>队列</code>的所有功能。</p><p><strong>JS实现</strong></p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 数组实现队列数据结构</span></span>
<span class="line"><span>const queue = []</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 入队</span></span>
<span class="line"><span>stack.push(0)</span></span>
<span class="line"><span>stack.push(1)</span></span>
<span class="line"><span>stack.push(2)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 出队</span></span>
<span class="line"><span>const shiftVal = stack.shift() // shiftVal 为 0</span></span></code></pre></div><p><strong>使用场景</strong></p><ul><li>场景一：日常测核酸排队</li><li>场景二：JS异步中的任务队列</li><li>场景三：计算最近请求次数</li></ul><p><strong>LeetCode题目</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">933</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  最近的请求次数</span></span></code></pre></div><h4 id="基本操作-1" tabindex="-1">基本操作 <a class="header-anchor" href="#基本操作-1" aria-label="Permalink to &quot;基本操作&quot;">​</a></h4><ol><li><strong>入队（Enqueue）</strong>：向队列的尾部添加一个元素。</li><li><strong>出队（Dequeue）</strong>：从队列的头部移除一个元素。</li><li><strong>查看队首元素（Peek/Front）</strong>：返回队列头部的元素，但不移除它。</li><li><strong>判断队列是否为空（IsEmpty）</strong>：检查队列中是否有元素。</li><li><strong>队列的大小（Size）</strong>：返回队列中元素的数量。</li></ol><h4 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><p>队列广泛应用于需要按顺序处理任务的场景，以下是一些典型的应用：</p><ul><li><strong>任务调度</strong>：操作系统中的任务调度常常使用队列来管理进程或线程，按照先到先处理的原则执行任务。</li><li><strong>消息队列</strong>：在分布式系统或异步通信中，消息队列用于存储和传递消息，保证消息按顺序被处理。</li><li><strong>打印任务</strong>：打印机的打印任务通常是排队的，先发送的任务先打印。</li><li><strong>广度优先搜索（BFS）</strong>：在图的广度优先遍历中，队列用来管理访问节点的顺序。</li></ul><h4 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h4><p>队列可以用数组、链表或者其他数据结构来实现。常见的两种实现方式是：</p><ol><li><strong>数组实现</strong>：队列可以用一个数组来存储元素，使用两个指针（头指针和尾指针）来表示队列的两端。 <ul><li>优点：实现简单。</li><li>缺点：在数组中间删除元素可能会导致大量元素移动，效率较低。</li></ul></li><li><strong>链表实现</strong>：队列也可以使用链表来实现，通过链表的头部进行出队操作，通过尾部进行入队操作。 <ul><li>优点：无固定大小限制，可以高效地进行插入和删除。</li><li>缺点：需要额外的内存来存储指针。</li></ul></li></ol><h4 id="操作" tabindex="-1">操作 <a class="header-anchor" href="#操作" aria-label="Permalink to &quot;操作&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Queue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 入队</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    enqueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 出队</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dequeue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Queue is empty&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shift</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从头部移除元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 查看队首元素</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    front</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Queue is empty&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 判断队列是否为空</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 返回队列大小</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 测试队列操作</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> queue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Queue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">enqueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 入队 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">enqueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 入队 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">enqueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 入队 3</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dequeue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 出队 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">front</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 队首元素 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 队列大小 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(queue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 是否为空 false</span></span></code></pre></div><h4 id="队列的变种" tabindex="-1">队列的变种 <a class="header-anchor" href="#队列的变种" aria-label="Permalink to &quot;队列的变种&quot;">​</a></h4><ul><li><strong>双端队列（Deque）</strong>：双端队列允许从队列的两端进行插入和删除操作，因此它既可以作为队列使用，也可以作为栈使用。</li><li><strong>优先级队列（Priority Queue）</strong>：优先级队列中的元素有优先级，出队时不是按顺序（FIFO）执行，而是根据元素的优先级进行处理，优先级高的元素先出队。</li></ul><h2 id="_3-链表" tabindex="-1">3. 链表 <a class="header-anchor" href="#_3-链表" aria-label="Permalink to &quot;3. 链表&quot;">​</a></h2><h4 id="认识-2" tabindex="-1">认识 <a class="header-anchor" href="#认识-2" aria-label="Permalink to &quot;认识&quot;">​</a></h4><p><strong>链表（Linked List）</strong> 是一种 <strong>线性数据结构</strong>，与数组类似，也用来存储一系列的元素。与数组不同的是，链表中的元素不是按连续的内存地址存储的，而是通过 <strong>节点</strong>（Node）之间的 <strong>指针</strong>（或引用）连接起来。</p><p><code>链表</code>是多个元素组成的列表，元素存储不连续，用<code>next</code>指针连在一起。<code>JavaScript</code>中没有<code>链表</code>，但是可以用<code>Object</code>模拟<code>链表</code>。</p><h4 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h4><p>一个链表由多个 <strong>节点</strong>（Node）组成，每个节点包含两个部分（<strong>数据+指针</strong>）</p><ol><li><strong>数据部分</strong>：存储节点的数据。</li><li><strong>指针部分</strong>：指向下一个节点的引用。对于链表中的最后一个节点，指针部分为 <code>null</code> 或 <code>undefined</code>，表示链表的结束。</li></ol><h4 id="类型" tabindex="-1">类型 <a class="header-anchor" href="#类型" aria-label="Permalink to &quot;类型&quot;">​</a></h4><ul><li><strong>单向链表（Singly Linked List）</strong>：每个节点指向下一个节点，链表是单向的。</li><li><strong>双向链表（Doubly Linked List）</strong>：每个节点有两个指针，一个指向下一个节点，一个指向前一个节点。</li><li><strong>循环链表（Circular Linked List）</strong>：链表的最后一个节点指向链表的头节点，形成循环。</li></ul><h4 id="链表与数组的比较" tabindex="-1">链表与数组的比较 <a class="header-anchor" href="#链表与数组的比较" aria-label="Permalink to &quot;链表与数组的比较&quot;">​</a></h4><table tabindex="0"><thead><tr><th>特性</th><th>链表</th><th>数组</th></tr></thead><tbody><tr><td>内存分配</td><td>非连续的内存分配</td><td>连续的内存分配</td></tr><tr><td>插入/删除效率</td><td>高效（O(1)）</td><td>低效（需要移动元素）</td></tr><tr><td>随机访问</td><td>低效（O(n)）</td><td>高效（O(1)）</td></tr><tr><td>空间效率</td><td>节省空间（不需要固定大小）</td><td>固定大小（需要预先分配）</td></tr></tbody></table><h4 id="链表的常见操作" tabindex="-1">链表的常见操作 <a class="header-anchor" href="#链表的常见操作" aria-label="Permalink to &quot;链表的常见操作&quot;">​</a></h4><ol><li><strong>插入（Insertion）</strong>：可以在链表的头部、尾部或任意位置插入节点。</li><li><strong>删除（Deletion）</strong>：可以删除链表的头部、尾部或指定位置的节点。</li><li><strong>遍历（Traversal）</strong>：从头节点开始逐一访问链表中的每个节点，直到链表的结束。</li><li><strong>查找（Search）</strong>：查找链表中是否有某个特定的数据。</li></ol><h4 id="在-javascript-中如何理解链表" tabindex="-1">在 JavaScript 中如何理解链表 <a class="header-anchor" href="#在-javascript-中如何理解链表" aria-label="Permalink to &quot;在 JavaScript 中如何理解链表&quot;">​</a></h4><p>在 JavaScript 中，链表通常通过 <strong>对象</strong> 来实现，因为 JavaScript 对象本身就能存储 <strong>键值对</strong>，而每个节点的指针可以用对象的属性来表示。</p><h4 id="ts实现" tabindex="-1">TS实现 <a class="header-anchor" href="#ts实现" aria-label="Permalink to &quot;TS实现&quot;">​</a></h4><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> /**</span></span>
<span class="line"><span> * 定义一个 node 节点</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>interface ILinkListNode {</span></span>
<span class="line"><span>    value: number</span></span>
<span class="line"><span>    next?: ILinkListNode</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * 根据数组创建单向链表</span></span>
<span class="line"><span> * @param arr </span></span>
<span class="line"><span> * @returns </span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>function createLinkList(arr: number[]): ILinkListNode {</span></span>
<span class="line"><span>    const len = arr.length</span></span>
<span class="line"><span>    if (len === 0) throw new Error(&#39;arr is empty&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let curNode: ILinkListNode = {</span></span>
<span class="line"><span>        value: arr[len - 1]</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    if (len === 1) return curNode</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    for (let i = len - 2; i &gt;= 0; i--) {</span></span>
<span class="line"><span>        curNode = {</span></span>
<span class="line"><span>            value: arr[i],</span></span>
<span class="line"><span>            next: curNode </span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return curNode</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><strong>使用场景</strong></p><ul><li>场景一：JS中的原型链</li><li>场景二：使用链表指针获取 JSON 的节点值</li></ul><p><strong>LeetCode题目</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">237.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 删除链表中的节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">206.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 反转链表</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 两数相加</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">83.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 删除排序链表中的重复元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">141.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 环形链表</span></span></code></pre></div><h4 id="单向链表的实现" tabindex="-1">单向链表的实现 <a class="header-anchor" href="#单向链表的实现" aria-label="Permalink to &quot;单向链表的实现&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 节点类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 节点数据</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指向下一个节点的指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 链表类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LinkedList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 链表的头部</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 添加节点到链表尾部</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 如果链表为空，将新节点设置为头节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newNode;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 否则找到链表的最后一个节点，并将其 next 指向新节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current.next) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        current.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newNode;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 打印链表的所有节点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39; -&gt; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;null&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 查找某个节点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current.data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 删除某个节点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    remove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 链表为空</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 如果要删除的是头节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head.data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head.next;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current.next) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current.next.data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                current.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.next.next;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 测试链表操作</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LinkedList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加节点 10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加节点 20</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加节点 30</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印链表 10 -&gt; 20 -&gt; 30 -&gt; null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 查找值为 20 的节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除值为 20 的节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印链表 10 -&gt; 30 -&gt; null</span></span></code></pre></div><h4 id="实际应用" tabindex="-1">实际应用 <a class="header-anchor" href="#实际应用" aria-label="Permalink to &quot;实际应用&quot;">​</a></h4><ol><li><strong>动态内存管理</strong>：链表在内存中分配空间时，不需要连续的内存空间，可以有效地利用碎片化的内存。</li><li><strong>实现队列和栈</strong>：链表可以用来实现队列（FIFO）和栈（LIFO）。链表的插入和删除操作是 O(1) 的，非常适合用来实现这两种数据结构。</li><li><strong>处理大量数据</strong>：对于大小动态变化的数据集，链表非常适合，因为它能够灵活地扩展而不需要移动已有的数据。</li></ol><h2 id="_4-集合" tabindex="-1">4-集合 <a class="header-anchor" href="#_4-集合" aria-label="Permalink to &quot;4-集合&quot;">​</a></h2><h3 id="认识-3" tabindex="-1">认识 <a class="header-anchor" href="#认识-3" aria-label="Permalink to &quot;认识&quot;">​</a></h3><p><strong>集合（Set）</strong> 是一种无序且元素唯一的数据结构，可以进行元素的添加、删除、查询等操作。</p><p>在 JavaScript 中，集合在 ES6 中引入，<code>Set</code> 提供了非常简便的 API 来进行常见的集合操作，如去重、判断元素是否存在、求交集等。</p><p>适用于需要去重、查找和集合运算的场景。</p><p>集合在数据处理、算法实现中非常有用，尤其是在处理大量数据时，能够提高效率。</p><p><strong>JS实现</strong></p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> // 去重</span></span>
<span class="line"><span>const arr = [1, 1, 2, 2]</span></span>
<span class="line"><span>const arr2 = [...new Set(arr)]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 判断元素是否在集合中</span></span>
<span class="line"><span>const set = new Set(arr)</span></span>
<span class="line"><span>const has = set.has(3) // false</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 求交集</span></span>
<span class="line"><span>const set2 = new Set([2, 3])</span></span>
<span class="line"><span>const set3 = new Set([...set].filter(item =&gt; set2.has(item)))</span></span></code></pre></div><p><strong>使用场景</strong></p><ul><li>场景一：求交集、差集</li></ul><p><strong>LeetCode题目</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">349</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 两个数组的交集</span></span></code></pre></div><h3 id="基本特性" tabindex="-1">基本特性 <a class="header-anchor" href="#基本特性" aria-label="Permalink to &quot;基本特性&quot;">​</a></h3><ol><li><strong>无序性</strong>：集合中的元素没有顺序，无法通过索引访问。</li><li><strong>唯一性</strong>：集合中每个元素都是唯一的，重复元素会被自动去除。</li><li><strong>快速查找</strong>：可以快速判断某个元素是否存在。</li></ol><h3 id="基本操作-2" tabindex="-1"><strong>基本操作</strong> <a class="header-anchor" href="#基本操作-2" aria-label="Permalink to &quot;**基本操作**&quot;">​</a></h3><p>以下是 ES6 中 <code>Set</code> 类型常用的操作：</p><ol><li><strong>去重</strong>：集合可以自动去除重复的元素。</li><li><strong>判断某元素是否存在</strong>：通过 <code>.has()</code> 方法判断某个元素是否在集合中。</li><li><strong>交集、差集</strong>：可以利用集合的特性方便地进行集合运算。</li></ol><h4 id="_1-去重操作" tabindex="-1"><strong>1. 去重操作</strong> <a class="header-anchor" href="#_1-去重操作" aria-label="Permalink to &quot;**1. 去重操作**&quot;">​</a></h4><p>在 JavaScript 中，利用 <code>Set</code> 可以轻松地去除数组中的重复元素：</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>javascriptCopy Code// 去重</span></span>
<span class="line"><span>const arr = [1, 1, 2, 2];</span></span>
<span class="line"><span>const arr2 = [...new Set(arr)];</span></span>
<span class="line"><span>console.log(arr2); // 输出: [1, 2]</span></span></code></pre></div><ul><li><strong>解析</strong>：<code>new Set(arr)</code> 创建了一个包含唯一元素的集合，通过 <code>...</code> 扩展运算符再将其转换回数组。</li></ul><hr><h4 id="_2-判断元素是否在集合中" tabindex="-1"><strong>2. 判断元素是否在集合中</strong> <a class="header-anchor" href="#_2-判断元素是否在集合中" aria-label="Permalink to &quot;**2. 判断元素是否在集合中**&quot;">​</a></h4><p>通过 <code>Set</code> 的 <code>has()</code> 方法，可以快速判断某个元素是否在集合中：</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>javascriptCopy Codeconst set = new Set([1, 2, 3]);</span></span>
<span class="line"><span>const has = set.has(3); // true</span></span>
<span class="line"><span>const notHas = set.has(4); // false</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(has);     // 输出: true</span></span>
<span class="line"><span>console.log(notHas);  // 输出: false</span></span></code></pre></div><ul><li><strong>解析</strong>：<code>has()</code> 返回一个布尔值，表示该元素是否存在于集合中。</li></ul><hr><h4 id="_3-求交集" tabindex="-1"><strong>3. 求交集</strong> <a class="header-anchor" href="#_3-求交集" aria-label="Permalink to &quot;**3. 求交集**&quot;">​</a></h4><p>可以通过集合的 <code>has()</code> 方法来实现两个集合的交集：</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>javascriptCopy Code// 求交集</span></span>
<span class="line"><span>const set1 = new Set([1, 2, 3]);</span></span>
<span class="line"><span>const set2 = new Set([2, 3, 4]);</span></span>
<span class="line"><span>const intersection = new Set([...set1].filter(item =&gt; set2.has(item)));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log([...intersection]); // 输出: [2, 3]</span></span></code></pre></div><ul><li><strong>解析</strong>：首先将 <code>set1</code> 转为数组，然后使用 <code>filter()</code> 方法筛选出同时存在于 <code>set2</code> 中的元素，最后将结果重新转为集合。</li></ul><hr><h4 id="_4-求差集" tabindex="-1"><strong>4. 求差集</strong> <a class="header-anchor" href="#_4-求差集" aria-label="Permalink to &quot;**4. 求差集**&quot;">​</a></h4><p>求差集即返回一个集合中存在，而另一个集合中不存在的元素：</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>javascriptCopy Code// 求差集</span></span>
<span class="line"><span>const set1 = new Set([1, 2, 3]);</span></span>
<span class="line"><span>const set2 = new Set([2, 3, 4]);</span></span>
<span class="line"><span>const difference = new Set([...set1].filter(item =&gt; !set2.has(item)));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log([...difference]); // 输出: [1]</span></span></code></pre></div><ul><li><strong>解析</strong>：<code>filter()</code> 通过 <code>!set2.has(item)</code> 判断元素是否不在 <code>set2</code> 中，从而得到 <code>set1</code> 和 <code>set2</code> 的差集。</li></ul><hr><h4 id="_5-求并集" tabindex="-1"><strong>5. 求并集</strong> <a class="header-anchor" href="#_5-求并集" aria-label="Permalink to &quot;**5. 求并集**&quot;">​</a></h4><p>求并集即返回两个集合的所有元素，不重复：</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>javascriptCopy Code// 求并集</span></span>
<span class="line"><span>const set1 = new Set([1, 2, 3]);</span></span>
<span class="line"><span>const set2 = new Set([3, 4, 5]);</span></span>
<span class="line"><span>const union = new Set([...set1, ...set2]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log([...union]); // 输出: [1, 2, 3, 4, 5]</span></span></code></pre></div><ul><li><strong>解析</strong>：通过展开运算符将两个集合的元素合并，再创建新的集合，这样就自动去除重复元素，实现了并集操作。</li></ul><h3 id="使用场景-1" tabindex="-1"><strong>使用场景</strong> <a class="header-anchor" href="#使用场景-1" aria-label="Permalink to &quot;**使用场景**&quot;">​</a></h3><ol><li><strong>去重操作</strong><ul><li>当我们需要移除数组中的重复元素时，<code>Set</code> 是一个非常有效的工具。例如，处理用户输入的唯一标识符、产品编号等。</li></ul></li><li><strong>集合运算</strong><ul><li>如求交集、差集、并集等。常常应用于数据分析、推荐系统、权限控制等领域。</li></ul></li><li><strong>快速查找</strong><ul><li>当需要频繁判断元素是否存在时，<code>Set</code> 提供了高效的 <code>has()</code> 方法，适用于高性能场景。</li></ul></li><li><strong>LeetCode题目</strong><ul><li><strong>349. 两个数组的交集</strong>：给定两个数组，返回它们的交集（即两个数组中共同出现的元素）。</li></ul></li></ol><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>javascriptCopy Code// LeetCode 349 解法</span></span>
<span class="line"><span>var intersection = function(nums1, nums2) {</span></span>
<span class="line"><span>  const set1 = new Set(nums1);</span></span>
<span class="line"><span>  const set2 = new Set(nums2);</span></span>
<span class="line"><span>  const result = [...set1].filter(item =&gt; set2.has(item));</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>};</span></span></code></pre></div><ul><li><strong>解析</strong>：将两个数组转为 <code>Set</code>，利用集合的交集特性来得到结果。</li></ul><h2 id="_5-字典-哈希" tabindex="-1">5-字典(哈希) <a class="header-anchor" href="#_5-字典-哈希" aria-label="Permalink to &quot;5-字典(哈希)&quot;">​</a></h2><p><code>字典</code>也是一种存储<code>唯一值</code>的数据结构，但它以<code>键值对</code>的形式存储。<code>ES6</code>中的字典名为<code>Map</code></p><p>字典（或称哈希表）通常通过 <strong>对象（Object）</strong> 或 <code>**Map**</code> 类型来实现，它们用于存储键值对（key-value pairs）。字典的核心特性是 <strong>通过键（key）快速访问值（value）</strong>，通常使用 <strong>哈希算法</strong> 来实现键到值的映射。</p><p><strong>JS实现</strong></p><p><code>Map</code> 中的键和值可以是任何类型（包括对象、函数等）</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> // 字典</span></span>
<span class="line"><span>const map = new Map()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 增</span></span>
<span class="line"><span>map.set(&#39;key1&#39;, &#39;value1&#39;)</span></span>
<span class="line"><span>map.set(&#39;key2&#39;, &#39;value2&#39;)</span></span>
<span class="line"><span>map.set(&#39;key3&#39;, &#39;value3&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 删</span></span>
<span class="line"><span>map.delete(&#39;key3&#39;)</span></span>
<span class="line"><span>// map.clear()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 改</span></span>
<span class="line"><span>map.set(&#39;key2&#39;, &#39;value222&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 查</span></span>
<span class="line"><span>map.get(&#39;key2&#39;)</span></span></code></pre></div><p><strong>使用场景</strong></p><ul><li>场景：leetcode刷题</li></ul><p><strong>LeetCode题目</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">349</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 两个数组的交集</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 有效括号</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 两数之和</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 无重复字符的最长子串</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">76</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 最小覆盖子串</span></span></code></pre></div><h4 id="对象-vs-map-区别" tabindex="-1">对象 vs <code>Map</code>：区别 <a class="header-anchor" href="#对象-vs-map-区别" aria-label="Permalink to &quot;对象 vs \`Map\`：区别&quot;">​</a></h4><p>尽管对象和 <code>Map</code> 都可以用来实现字典，二者在使用上有一些重要的区别：</p><table tabindex="0"><thead><tr><th>特性</th><th>对象 (Object)</th><th><code>Map</code></th></tr></thead><tbody><tr><td>键的类型</td><td>只能是字符串或符号（Symbol）</td><td>可以是任何类型（包括对象、函数等）</td></tr><tr><td>键值对的顺序</td><td>没有保证（ES6 后的对象会保持插入顺序）</td><td>保持插入顺序</td></tr><tr><td>性能</td><td>键值对较少时性能较好，随着属性增加可能变慢</td><td>在添加、删除大量键值对时性能更好</td></tr><tr><td>默认原型</td><td>继承自 <code>Object.prototype</code><br>，可能包含其他属性</td><td>没有继承自 <code>Object</code><br>，没有额外的属性</td></tr><tr><td>Object.keys()<code>&lt;br/&gt;</code>Object.values()\`<br> 等</td><td><code>set()</code><br><code>get()</code><br><code>has()</code><br><code>delete()</code><br> 等</td><td></td></tr><tr><td>迭代器</td><td>不支持直接迭代（需要手动转换为数组）</td><td>直接支持迭代（<code>forEach()</code><br> 和 <code>for...of</code><br>）</td></tr></tbody></table><h2 id="_6-树" tabindex="-1">6-树 <a class="header-anchor" href="#_6-树" aria-label="Permalink to &quot;6-树&quot;">​</a></h2><h3 id="认识-4" tabindex="-1">认识 <a class="header-anchor" href="#认识-4" aria-label="Permalink to &quot;认识&quot;">​</a></h3><p>树（Tree）是一种常用的数据结构，它由节点（node）和连接节点的边（edge）组成，具有层次性和递归结构。树的特点是每个节点有一个父节点，除了根节点没有父节点，每个节点可以有多个子节点。</p><p><code>树</code>是一种<code>分层</code>的数据模型。前端常见的树包括：DOM、树、级联选择、树形控件……。<code>JavaScript</code>中没有<code>树</code>，但是可以通过<code>Object</code>和<code>Array</code>构建<code>树</code>。树的常用操作：深度/广度优先遍历、先中后序遍历。</p><p><strong>TS实现</strong></p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> /**</span></span>
<span class="line"><span> * 前序遍历：root -&gt; left -&gt; right</span></span>
<span class="line"><span> * 中序遍历：left -&gt; root -&gt; right</span></span>
<span class="line"><span> * 后序遍历：left -&gt; right -&gt; root</span></span>
<span class="line"><span> * 问1：为什么二叉树很重要，而不是三叉树、四叉树？</span></span>
<span class="line"><span> * 答：</span></span>
<span class="line"><span> * （1）数组、链表各有缺点</span></span>
<span class="line"><span> * （2）特定的二叉树（BBST，平衡二叉树）可以结合数组 &amp; 链表的优点，让整体查找效果最优（可用二分法）</span></span>
<span class="line"><span> * （3）各种高级二叉树（红黑数、B树），继续优化，满足不同场景</span></span>
<span class="line"><span> * 问2：堆特点？和二叉树的关系？</span></span>
<span class="line"><span> * 答：</span></span>
<span class="line"><span> * （1）逻辑结构是一棵二叉树</span></span>
<span class="line"><span> * （2）物理结构是一个数组</span></span>
<span class="line"><span> * （3）数组：连续内存 + 节省空间</span></span>
<span class="line"><span> * （4）查询比 BST 慢</span></span>
<span class="line"><span> * （5）增删比 BST 快，维持平衡更快</span></span>
<span class="line"><span> * （6）整体时间复杂度都在 O(logn) 级别，与树一致</span></span>
<span class="line"><span> * @description 二叉搜索树</span></span>
<span class="line"><span> * @author hovinghuang</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>interface ITreeNode {</span></span>
<span class="line"><span>    value: number</span></span>
<span class="line"><span>    left: ITreeNode | null</span></span>
<span class="line"><span>    right: ITreeNode | null</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const treeArr: number[] = []</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * 前序遍历</span></span>
<span class="line"><span> * @param node </span></span>
<span class="line"><span> * @returns </span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>function preOrderTraverse(node: ITreeNode | null): void {</span></span>
<span class="line"><span>    if (node == null) return</span></span>
<span class="line"><span>    console.info(node.value)</span></span>
<span class="line"><span>    treeArr.push(node.value)</span></span>
<span class="line"><span>    preOrderTraverse(node.left)</span></span>
<span class="line"><span>    preOrderTraverse(node.right)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * 中序遍历</span></span>
<span class="line"><span> * @param node </span></span>
<span class="line"><span> * @returns </span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>function inOrderTraverse(node: ITreeNode | null): void {</span></span>
<span class="line"><span>    if (node == null) return</span></span>
<span class="line"><span>    inOrderTraverse(node.left)</span></span>
<span class="line"><span>    console.info(node.value)</span></span>
<span class="line"><span>    treeArr.push(node.value)</span></span>
<span class="line"><span>    inOrderTraverse(node.right)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/**</span></span>
<span class="line"><span> * 后序遍历</span></span>
<span class="line"><span> * @param node </span></span>
<span class="line"><span> * @returns </span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>function postOrderTraverse(node: ITreeNode | null): void {</span></span>
<span class="line"><span>    if (node == null) return</span></span>
<span class="line"><span>    postOrderTraverse(node.left)</span></span>
<span class="line"><span>    postOrderTraverse(node.right)</span></span>
<span class="line"><span>    console.info(node.value)</span></span>
<span class="line"><span>    treeArr.push(node.value)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function getKthValue(node: ITreeNode, k: number): number | null {</span></span>
<span class="line"><span>    inOrderTraverse(bst)</span></span>
<span class="line"><span>    return treeArr[k - 1] || null</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const bst: ITreeNode = {</span></span>
<span class="line"><span>    value: 5,</span></span>
<span class="line"><span>    left: {</span></span>
<span class="line"><span>        value: 3,</span></span>
<span class="line"><span>        left: {</span></span>
<span class="line"><span>            value: 2,</span></span>
<span class="line"><span>            left: null,</span></span>
<span class="line"><span>            right: null</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        right: {</span></span>
<span class="line"><span>            value: 4,</span></span>
<span class="line"><span>            left: null,</span></span>
<span class="line"><span>            right: null,</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    right: {</span></span>
<span class="line"><span>        value: 7,</span></span>
<span class="line"><span>        left: {</span></span>
<span class="line"><span>            value: 6,</span></span>
<span class="line"><span>            left: null,</span></span>
<span class="line"><span>            right: null</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        right: {</span></span>
<span class="line"><span>            value: 8,</span></span>
<span class="line"><span>            left: null,</span></span>
<span class="line"><span>            right: null</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 功能测试</span></span>
<span class="line"><span>// preOrderTraverse(bst)</span></span>
<span class="line"><span>// inOrderTraverse(bst)</span></span>
<span class="line"><span>// postOrderTraverse(bst)</span></span>
<span class="line"><span>// console.info(&#39;第3小值&#39;, getKthValue(bst, 3))</span></span></code></pre></div><p><strong>使用场景</strong></p><ul><li>场景一：DOM树</li><li>场景二：级联选择器</li></ul><p><strong>LeetCode题目</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">104.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 二叉树的最大深度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">111.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 二叉树的最小深度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">102.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 二叉树的层序遍历</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">94.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 二叉树的中序遍历</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">112.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 路径总和</span></span></code></pre></div><h4 id="树的基本概念" tabindex="-1">树的基本概念 <a class="header-anchor" href="#树的基本概念" aria-label="Permalink to &quot;树的基本概念&quot;">​</a></h4><ul><li><strong>节点（Node）</strong>：树中的基本元素，包含值或数据。每个节点由数据部分和指向子节点的指针（或者引用）组成。</li><li><strong>根节点（Root）</strong>：树的顶端节点，没有父节点。</li><li><strong>父节点（Parent）</strong>：某个节点的直接上级节点。</li><li><strong>子节点（Child）</strong>：某个节点的直接下级节点。</li><li><strong>叶子节点（Leaf）</strong>：没有子节点的节点。</li><li><strong>子树（Subtree）</strong>：树的某个节点及其所有后代节点。</li><li><strong>深度（Depth）</strong>：从根节点到该节点的路径长度。</li><li><strong>高度（Height）</strong>：从该节点到最远叶子节点的路径长度。</li><li><strong>度（Degree）</strong>：节点的子节点个数。</li></ul><h4 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h4><p>根据不同的结构和用途，树可以有许多不同的类型，常见的包括：</p><ul><li><strong>二叉树（Binary Tree）</strong>：每个节点最多有两个子节点，通常称为左子节点和右子节点。 <ul><li><strong>满二叉树（Full Binary Tree）</strong>：每个节点要么是叶子节点，要么有两个子节点。</li><li><strong>完全二叉树（Complete Binary Tree）</strong>：除了最后一层，其他层的节点都达到最大，且最后一层的节点从左到右依次排列。</li></ul></li><li><strong>二叉搜索树（Binary Search Tree，BST）</strong>：对于每个节点，左子树的值小于节点的值，右子树的值大于节点的值。</li><li><strong>平衡树（Balanced Tree）</strong>：为了保证高效的查询、插入和删除操作，树的高度尽量保持平衡。 <ul><li><strong>AVL树</strong>：一种高度平衡的二叉搜索树，任何一个节点的两个子树的高度差的绝对值不超过1。</li><li><strong>红黑树</strong>：一种自平衡的二叉搜索树，每个节点都有额外的颜色属性（红色或黑色），通过颜色规则保持平衡。</li></ul></li><li><strong>B树和B+树</strong>：用于数据库和文件系统，支持大规模数据的高效插入、删除、查找等操作。</li></ul><h3 id="树的常见操作" tabindex="-1"><strong>树的常见操作</strong> <a class="header-anchor" href="#树的常见操作" aria-label="Permalink to &quot;**树的常见操作**&quot;">​</a></h3><h4 id="_3-1-插入节点" tabindex="-1">3.1 插入节点 <a class="header-anchor" href="#_3-1-插入节点" aria-label="Permalink to &quot;3.1 插入节点&quot;">​</a></h4><ul><li>在树中插入一个节点通常依赖于树的类型。例如，在二叉搜索树中，新的节点会插入到合适的位置，遵循左小右大的规则。</li></ul><h4 id="_3-2-删除节点" tabindex="-1">3.2 删除节点 <a class="header-anchor" href="#_3-2-删除节点" aria-label="Permalink to &quot;3.2 删除节点&quot;">​</a></h4><ul><li>删除树中的节点时需要考虑该节点的子节点。如果节点是叶子节点，直接删除；如果有一个子节点，删除节点并将子节点提升；如果有两个子节点，通常选择右子树中的最小节点或左子树中的最大节点来替代删除节点。</li></ul><h4 id="_3-3-查找节点" tabindex="-1">3.3 查找节点 <a class="header-anchor" href="#_3-3-查找节点" aria-label="Permalink to &quot;3.3 查找节点&quot;">​</a></h4><ul><li>查找操作在二叉搜索树中非常高效，因为它利用树的排序特性，可以在O(log n)的时间复杂度内完成查找。</li></ul><h4 id="_3-4-遍历树" tabindex="-1">3.4 遍历树 <a class="header-anchor" href="#_3-4-遍历树" aria-label="Permalink to &quot;3.4 遍历树&quot;">​</a></h4><p>树的遍历是树结构的基本操作，常见的遍历方式有：</p><ul><li><strong>前序遍历（Preorder Traversal）</strong>：先访问根节点，然后访问左子树，再访问右子树。</li></ul><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>textCopy Code根 → 左 → 右</span></span></code></pre></div><ul><li><strong>中序遍历（Inorder Traversal）</strong>：先访问左子树，然后访问根节点，再访问右子树。</li></ul><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>textCopy Code左 → 根 → 右</span></span></code></pre></div><ul><li><strong>后序遍历（Postorder Traversal）</strong>：先访问左子树，然后访问右子树，最后访问根节点。</li></ul><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>textCopy Code左 → 右 → 根</span></span></code></pre></div><ul><li><strong>层次遍历（Level Order Traversal）</strong>：按层级顺序访问树的节点，通常使用队列实现。</li></ul><h3 id="实现-1" tabindex="-1"><strong>实现</strong> <a class="header-anchor" href="#实现-1" aria-label="Permalink to &quot;**实现**&quot;">​</a></h3><p>在实际编程中，树通常通过类（class）或结构体（struct）来实现。以下是一个简单的二叉树实现示例：</p><h4 id="_4-1-二叉树节点的定义" tabindex="-1">4.1 二叉树节点的定义 <a class="header-anchor" href="#_4-1-二叉树节点的定义" aria-label="Permalink to &quot;4.1 二叉树节点的定义&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_4-2-二叉搜索树的插入操作" tabindex="-1">4.2 二叉搜索树的插入操作 <a class="header-anchor" href="#_4-2-二叉搜索树的插入操作" aria-label="Permalink to &quot;4.2 二叉搜索树的插入操作&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BinarySearchTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newNode;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_insertNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.root, newNode);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  _insertNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newNode.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.value) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        node.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newNode;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_insertNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node.left, newNode);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node.right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        node.right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newNode;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_insertNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node.right, newNode);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_4-3-二叉树的前序遍历" tabindex="-1">4.3 二叉树的前序遍历 <a class="header-anchor" href="#_4-3-二叉树的前序遍历" aria-label="Permalink to &quot;4.3 二叉树的前序遍历&quot;">​</a></h4><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> class BinaryTree {</span></span>
<span class="line"><span>    constructor() {</span></span>
<span class="line"><span>        this.root = null;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    preorderTraversal(node) {</span></span>
<span class="line"><span>        if (node !== null) {</span></span>
<span class="line"><span>            console.log(node.value); // 访问节点</span></span>
<span class="line"><span>            this.preorderTraversal(node.left); // 访问左子树</span></span>
<span class="line"><span>            this.preorderTraversal(node.right); // 访问右子树</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="应用场景-1" tabindex="-1"><strong>应用场景</strong> <a class="header-anchor" href="#应用场景-1" aria-label="Permalink to &quot;**应用场景**&quot;">​</a></h3><ul><li><strong>数据库索引</strong>：B树和B+树广泛用于数据库索引中，支持高效的数据查找、插入、删除操作。</li><li><strong>文件系统</strong>：目录结构通常用树来表示，文件夹是父节点，文件是子节点。</li><li><strong>编译器</strong>：语法树用于表示程序的语法结构。</li><li><strong>搜索引擎</strong>：倒排索引结构常使用树来表示。</li><li><strong>人工智能</strong>：决策树用于机器学习中的分类任务。</li></ul><h2 id="_7-图" tabindex="-1">7. 图 <a class="header-anchor" href="#_7-图" aria-label="Permalink to &quot;7. 图&quot;">​</a></h2><p>图（Graph）是一种非线性的数据结构，用于表示物体之间的关系。图由一组节点（Vertex）和一组边（Edge）组成，其中边连接着图中的两个节点。图在现实生活中有很多应用，比如社交网络、交通系统、互联网拓扑结构等。</p><p><code>图</code>是网络结构的抽象模型，是一组由边连接的节点。图可以表示任何二元关系，比如道路、航班。JS中没有图，但是可以用<code>Object</code>和<code>Array</code>构建<code>图</code>。图的表示法：邻接矩阵、邻接表、关联矩阵。</p><h3 id="基本概念-1" tabindex="-1"><strong>基本概念</strong> <a class="header-anchor" href="#基本概念-1" aria-label="Permalink to &quot;**基本概念**&quot;">​</a></h3><ul><li><strong>节点（Vertex）</strong>：图中的基本元素，表示物体或者状态。</li><li><strong>边（Edge）</strong>：连接图中两个节点的线，表示节点之间的关系或联系。边有两种类型： <ul><li><strong>有向边（Directed Edge）</strong>：边有方向，从一个节点指向另一个节点。</li><li><strong>无向边（Undirected Edge）</strong>：边没有方向，连接的两个节点是对等的。</li></ul></li><li><strong>邻接（Adjacency）</strong>：两个节点之间如果有边连接，称这两个节点是邻接的。</li><li><strong>度（Degree）</strong>：一个节点的度是与它相连接的边的数目。 <ul><li><strong>入度（Indegree）</strong>：指向该节点的边的数量（仅适用于有向图）。</li><li><strong>出度（Outdegree）</strong>：从该节点指向其他节点的边的数量（仅适用于有向图）。</li></ul></li></ul><h3 id="表示" tabindex="-1">表示 <a class="header-anchor" href="#表示" aria-label="Permalink to &quot;表示&quot;">​</a></h3><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 邻接表表示图结构</span></span>
<span class="line"><span>const graph = {</span></span>
<span class="line"><span>    0: [1, 2],</span></span>
<span class="line"><span>    1: [2],</span></span>
<span class="line"><span>    2: [0, 3],</span></span>
<span class="line"><span>    3: [3]</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 深度优先遍历</span></span>
<span class="line"><span>const visited = new Set()</span></span>
<span class="line"><span>function dfs(n, visited) { // n 表示开始访问的根节点</span></span>
<span class="line"><span>    console.log(n)</span></span>
<span class="line"><span>    visited.add(n)</span></span>
<span class="line"><span>    graph[n].forEach((item) =&gt; {</span></span>
<span class="line"><span>        if (!visited.has(item)) dfs(item, visited) </span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>dfs(2, visited) // 2 0 1 3</span></span>
<span class="line"><span>console.log(visited) // {2, 0, 1, 3}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 广度优先遍历</span></span>
<span class="line"><span>function bfs(n) { // n 表示开始访问的根节点</span></span>
<span class="line"><span>    const visited = new Set()</span></span>
<span class="line"><span>    visited.add(n)</span></span>
<span class="line"><span>    const queue = [n]</span></span>
<span class="line"><span>    while (queue.length) {</span></span>
<span class="line"><span>        const shiftVal = queue.shift()</span></span>
<span class="line"><span>        graph[shiftVal].forEach((item) =&gt; {</span></span>
<span class="line"><span>            if (!visited.has(item)) {</span></span>
<span class="line"><span>                queue.push(item)</span></span>
<span class="line"><span>                visited.add(item)</span></span>
<span class="line"><span>            } </span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    console.log(visited) // {2, 0, 3, 1}</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>bfs(2)</span></span></code></pre></div><p><strong>使用场景</strong></p><ul><li>场景一：道路</li><li>场景二：航班</li></ul><p><strong>LeetCode题目</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">65</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 有效数字</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">417</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 太平洋大西洋水流问题</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">133</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 克隆图</span></span></code></pre></div><h3 id="分类-1" tabindex="-1"><strong>分类</strong> <a class="header-anchor" href="#分类-1" aria-label="Permalink to &quot;**分类**&quot;">​</a></h3><p>图可以根据不同的特征进行分类：</p><h4 id="_2-1-根据边的方向" tabindex="-1">2.1 根据边的方向 <a class="header-anchor" href="#_2-1-根据边的方向" aria-label="Permalink to &quot;2.1 根据边的方向&quot;">​</a></h4><ul><li><strong>有向图（Directed Graph, Digraph）</strong>：每条边都有一个方向，边从一个节点指向另一个节点。比如社交网络中“关注”关系可以用有向图表示。</li><li><strong>无向图（Undirected Graph）</strong>：边没有方向，两个节点之间的边没有特定的起始点或终点。比如道路网络、社交网络中的“朋友”关系可以用无向图表示。</li></ul><h4 id="_2-2-根据边的数量" tabindex="-1">2.2 根据边的数量 <a class="header-anchor" href="#_2-2-根据边的数量" aria-label="Permalink to &quot;2.2 根据边的数量&quot;">​</a></h4><ul><li><strong>简单图（Simple Graph）</strong>：没有自环（一个节点不能通过一条边指向自己）和重复的边。</li><li><strong>多重图（Multigraph）</strong>：允许多条边连接同一对节点。</li><li><strong>带权图（Weighted Graph）</strong>：每条边都有一个权重，表示节点之间的距离或成本。常见于网络流、地图导航等应用中。</li></ul><h4 id="_2-3-根据图的连通性" tabindex="-1">2.3 根据图的连通性 <a class="header-anchor" href="#_2-3-根据图的连通性" aria-label="Permalink to &quot;2.3 根据图的连通性&quot;">​</a></h4><ul><li><strong>连通图（Connected Graph）</strong>：图中的任意两个节点都有路径相连。 <ul><li>对于无向图，连通图指的是图中的任意两点之间都存在路径。</li><li>对于有向图，强连通图指的是任意两个节点之间都可以互相到达。</li></ul></li><li><strong>非连通图（Disconnected Graph）</strong>：图中存在至少一对节点之间没有路径连接。</li></ul><h4 id="_2-4-根据图的结构" tabindex="-1">2.4 根据图的结构 <a class="header-anchor" href="#_2-4-根据图的结构" aria-label="Permalink to &quot;2.4 根据图的结构&quot;">​</a></h4><ul><li><strong>树（Tree）</strong>：一种特殊的图，没有环（循环），是一个连通无环的有向图或无向图。</li><li><strong>有向无环图（Directed Acyclic Graph, DAG）</strong>：有向图且没有环，常用于表示依赖关系，比如任务调度、版本控制等。</li></ul><h3 id="图的表示方法" tabindex="-1"><strong>图的表示方法</strong> <a class="header-anchor" href="#图的表示方法" aria-label="Permalink to &quot;**图的表示方法**&quot;">​</a></h3><p>图可以通过以下几种方式进行表示：</p><h4 id="_3-1-邻接矩阵-adjacency-matrix" tabindex="-1">3.1 邻接矩阵（Adjacency Matrix） <a class="header-anchor" href="#_3-1-邻接矩阵-adjacency-matrix" aria-label="Permalink to &quot;3.1 邻接矩阵（Adjacency Matrix）&quot;">​</a></h4><p>邻接矩阵是一个二维数组，其中矩阵的行和列都表示图中的节点。如果节点 i_i_ 和节点 j_j_ 之间有边，则矩阵元素 A[i][j]=1_A_[<em>i</em>][<em>j</em>]=1（对于无权图）或 A[i][j]=边的权重_A_[<em>i</em>][<em>j</em>]=边的权重（对于带权图）；如果没有边，则为 0。</p><ul><li><strong>优点</strong>：方便进行图的操作（如查找某两节点之间是否有边），但空间复杂度较高。</li><li><strong>缺点</strong>：存储空间复杂度为 O(V2)<em>O</em>(<em>V_2)，其中 V_V</em> 为节点数。对于稀疏图，效率较低。</li></ul><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pythonCopy Code# 邻接矩阵表示图</span></span>
<span class="line"><span>graph = [</span></span>
<span class="line"><span>    [0, 1, 0, 0],</span></span>
<span class="line"><span>    [1, 0, 1, 1],</span></span>
<span class="line"><span>    [0, 1, 0, 0],</span></span>
<span class="line"><span>    [0, 1, 0, 0]</span></span>
<span class="line"><span>]</span></span></code></pre></div><h4 id="_3-2-邻接表-adjacency-list" tabindex="-1">3.2 邻接表（Adjacency List） <a class="header-anchor" href="#_3-2-邻接表-adjacency-list" aria-label="Permalink to &quot;3.2 邻接表（Adjacency List）&quot;">​</a></h4><p>邻接表是一种更节省空间的表示方法。它使用一个数组或链表来存储每个节点的所有邻接节点。每个节点都有一个链表，链表中的元素表示该节点与其他节点的边。</p><ul><li><strong>优点</strong>：空间复杂度较低，适用于稀疏图。</li><li><strong>缺点</strong>：查找两个节点之间是否有边较慢。</li></ul><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pythonCopy Code# 邻接表表示图</span></span>
<span class="line"><span>graph = {</span></span>
<span class="line"><span>    0: [1],</span></span>
<span class="line"><span>    1: [0, 2, 3],</span></span>
<span class="line"><span>    2: [1],</span></span>
<span class="line"><span>    3: [1]</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="_3-3-边列表-edge-list" tabindex="-1">3.3 边列表（Edge List） <a class="header-anchor" href="#_3-3-边列表-edge-list" aria-label="Permalink to &quot;3.3 边列表（Edge List）&quot;">​</a></h4><p>边列表是通过一个边的集合来表示图，每一条边表示为一个二元组或三元组（带权边）。这种表示方式常用于存储图的数据结构，特别适合于边的遍历。</p><ul><li><strong>优点</strong>：表示方式简洁，适合边的处理。</li><li><strong>缺点</strong>：对于图的其他操作（如查找节点的邻居）较为不便。</li></ul><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pythonCopy Code# 边列表表示图</span></span>
<span class="line"><span>graph = [(0, 1), (1, 2), (1, 3)]</span></span></code></pre></div><h3 id="常见操作" tabindex="-1"><strong>常见操作</strong> <a class="header-anchor" href="#常见操作" aria-label="Permalink to &quot;**常见操作**&quot;">​</a></h3><h4 id="_4-1-遍历图" tabindex="-1">4.1 遍历图 <a class="header-anchor" href="#_4-1-遍历图" aria-label="Permalink to &quot;4.1 遍历图&quot;">​</a></h4><ul><li><strong>深度优先搜索（DFS）</strong>：从一个节点开始，尽可能深地遍历图，直到无法继续，再回溯到上一个节点。适合用栈实现。</li></ul><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pythonCopy Codedef dfs(graph, start, visited=None):</span></span>
<span class="line"><span>    if visited is None:</span></span>
<span class="line"><span>        visited = set()</span></span>
<span class="line"><span>    visited.add(start)</span></span>
<span class="line"><span>    for neighbor in graph[start]:</span></span>
<span class="line"><span>        if neighbor not in visited:</span></span>
<span class="line"><span>            dfs(graph, neighbor, visited)</span></span>
<span class="line"><span>    return visited</span></span></code></pre></div><ul><li><strong>广度优先搜索（BFS）</strong>：从一个节点开始，先访问所有邻居节点，再逐层访问更远的节点，适合用队列实现。</li></ul><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pythonCopy Codefrom collections import deque</span></span>
<span class="line"><span>def bfs(graph, start):</span></span>
<span class="line"><span>    visited = set()</span></span>
<span class="line"><span>    queue = deque([start])</span></span>
<span class="line"><span>    while queue:</span></span>
<span class="line"><span>        vertex = queue.popleft()</span></span>
<span class="line"><span>        if vertex not in visited:</span></span>
<span class="line"><span>            visited.add(vertex)</span></span>
<span class="line"><span>            queue.extend(graph[vertex] - visited)</span></span>
<span class="line"><span>    return visited</span></span></code></pre></div><h4 id="_4-2-查找最短路径" tabindex="-1">4.2 查找最短路径 <a class="header-anchor" href="#_4-2-查找最短路径" aria-label="Permalink to &quot;4.2 查找最短路径&quot;">​</a></h4><ul><li><strong>Dijkstra算法</strong>：用于找出从起始节点到其他所有节点的最短路径，适用于带权图。</li><li><strong>Bellman-Ford算法</strong>：可以处理带负权边的图，能够检测负权环。</li></ul><h4 id="_4-3-拓扑排序" tabindex="-1">4.3 拓扑排序 <a class="header-anchor" href="#_4-3-拓扑排序" aria-label="Permalink to &quot;4.3 拓扑排序&quot;">​</a></h4><p>拓扑排序是有向无环图（DAG）中的一种排序方式，按照边的依赖关系将图的节点进行排序。常用于任务调度、编译顺序等。</p><h3 id="应用场景-2" tabindex="-1"><strong>应用场景</strong> <a class="header-anchor" href="#应用场景-2" aria-label="Permalink to &quot;**应用场景**&quot;">​</a></h3><ul><li><strong>社交网络</strong>：图用于表示人与人之间的关系，节点是人，边是社交联系。</li><li><strong>互联网</strong>：图表示网页与网页之间的链接关系，节点是网页，边是超链接。</li><li><strong>地图与导航</strong>：图可以表示交通网络，节点是交叉口或地点，边是道路或路线。</li><li><strong>任务调度与依赖关系</strong>：图用于表示任务间的依赖关系，拓扑排序可以帮助确定任务的执行顺序。</li><li><strong>计算机网络</strong>：图用于表示计算机网络中的路由和数据流。</li></ul><h2 id="_8-堆-heap" tabindex="-1">8-堆（Heap） <a class="header-anchor" href="#_8-堆-heap" aria-label="Permalink to &quot;8-堆（Heap）&quot;">​</a></h2><p>堆是一种特殊的完全二叉树数据结构，满足一定的顺序性质。</p><p>所有的节点都大于等于（最大堆）或小于等于（最小堆）它的子节点。由于<code>堆</code>的特殊结构，我们可以用<code>数组</code>表示<code>堆</code>。</p><p>堆广泛应用于实现优先队列、堆排序等算法。</p><h3 id="基本概念-2" tabindex="-1"><strong>基本概念</strong> <a class="header-anchor" href="#基本概念-2" aria-label="Permalink to &quot;**基本概念**&quot;">​</a></h3><p>堆是一棵完全二叉树，满足堆的性质。根据堆的性质，堆分为两种类型：</p><h4 id="_1-1-最大堆-max-heap" tabindex="-1">1.1 <strong>最大堆（Max-Heap）</strong> <a class="header-anchor" href="#_1-1-最大堆-max-heap" aria-label="Permalink to &quot;1.1 **最大堆（Max-Heap）**&quot;">​</a></h4><p>在最大堆中，任何一个节点的值都不小于其子节点的值。也就是说，堆顶元素是整个堆中最大的元素。</p><ul><li><strong>堆的性质</strong>：父节点的值大于或等于子节点的值。</li><li><strong>堆的形状</strong>：完全二叉树，每层节点从左到右依次排列，且最后一层的节点填充到最左边。</li></ul><h4 id="_1-2-最小堆-min-heap" tabindex="-1">1.2 <strong>最小堆（Min-Heap）</strong> <a class="header-anchor" href="#_1-2-最小堆-min-heap" aria-label="Permalink to &quot;1.2 **最小堆（Min-Heap）**&quot;">​</a></h4><p>在最小堆中，任何一个节点的值都不大于其子节点的值。也就是说，堆顶元素是整个堆中最小的元素。</p><ul><li><strong>堆的性质</strong>：父节点的值小于或等于子节点的值。</li><li><strong>堆的形状</strong>：同样是完全二叉树。</li></ul><h3 id="表示-1" tabindex="-1">表示 <a class="header-anchor" href="#表示-1" aria-label="Permalink to &quot;表示&quot;">​</a></h3><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    1</span></span>
<span class="line"><span>   / \\</span></span>
<span class="line"><span>  2   3</span></span>
<span class="line"><span> / \\  /\\</span></span>
<span class="line"><span>4  5 6</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 数组表示堆结构</span></span>
<span class="line"><span>const heap = [1, 2, 3, 4, 5, 6]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 实现一个最小堆类</span></span>
<span class="line"><span>class MinHeap {</span></span>
<span class="line"><span>    constructor() {</span></span>
<span class="line"><span>        this.heap = [];</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    swap(i1, i2) {</span></span>
<span class="line"><span>        const temp = this.heap[i1];</span></span>
<span class="line"><span>        this.heap[i1] = this.heap[i2];</span></span>
<span class="line"><span>        this.heap[i2] = temp;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    getParentIndex(i) {</span></span>
<span class="line"><span>        return (i - 1) &gt;&gt; 1;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    getLeftIndex(i) {</span></span>
<span class="line"><span>        return i * 2 + 1;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    getRightIndex(i) {</span></span>
<span class="line"><span>        return i * 2 + 2;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    shiftUp(index) {</span></span>
<span class="line"><span>        if (index == 0) { return; }</span></span>
<span class="line"><span>        const parentIndex = this.getParentIndex(index);</span></span>
<span class="line"><span>        if (this.heap[parentIndex] &gt; this.heap[index]) {</span></span>
<span class="line"><span>            this.swap(parentIndex, index);</span></span>
<span class="line"><span>            this.shiftUp(parentIndex);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    shiftDown(index) {</span></span>
<span class="line"><span>        const leftIndex = this.getLeftIndex(index);</span></span>
<span class="line"><span>        const rightIndex = this.getRightIndex(index);</span></span>
<span class="line"><span>        if (this.heap[leftIndex] &lt; this.heap[index]) {</span></span>
<span class="line"><span>            this.swap(leftIndex, index);</span></span>
<span class="line"><span>            this.shiftDown(leftIndex);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        if (this.heap[rightIndex] &lt; this.heap[index]) {</span></span>
<span class="line"><span>            this.swap(rightIndex, index);</span></span>
<span class="line"><span>            this.shiftDown(rightIndex);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    insert(value) {</span></span>
<span class="line"><span>        this.heap.push(value);</span></span>
<span class="line"><span>        this.shiftUp(this.heap.length - 1);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    pop() {</span></span>
<span class="line"><span>        this.heap[0] = this.heap.pop();</span></span>
<span class="line"><span>        this.shiftDown(0);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    peek() {</span></span>
<span class="line"><span>        return this.heap[0];</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    size() {</span></span>
<span class="line"><span>        return this.heap.length;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const h = new MinHeap();</span></span>
<span class="line"><span>h.insert(3);</span></span>
<span class="line"><span>h.insert(2);</span></span>
<span class="line"><span>h.insert(1);</span></span>
<span class="line"><span>h.pop();</span></span></code></pre></div><p><strong>使用场景</strong></p><ul><li>场景：leetcode刷题</li></ul><p><strong>LeetCode题目</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">215</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  数组中的第K个最大元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">347</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  前 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 个高频元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">● </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">23</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  合并K个升序链表</span></span></code></pre></div><h3 id="表示-2" tabindex="-1"><strong>表示</strong> <a class="header-anchor" href="#表示-2" aria-label="Permalink to &quot;**表示**&quot;">​</a></h3><p>堆通常用一个数组来表示。数组的下标和堆的结构有着密切的关系：</p><ul><li><strong>父节点</strong>：对于一个数组下标为 <code>i</code> 的节点，其父节点下标为 <code>floor((i-1) / 2)</code>。</li><li><strong>左子节点</strong>：对于一个数组下标为 <code>i</code> 的节点，其左子节点下标为 <code>2 * i + 1</code>。</li><li><strong>右子节点</strong>：对于一个数组下标为 <code>i</code> 的节点，其右子节点下标为 <code>2 * i + 2</code></li></ul><h3 id="操作-1" tabindex="-1"><strong>操作</strong> <a class="header-anchor" href="#操作-1" aria-label="Permalink to &quot;**操作**&quot;">​</a></h3><p>堆支持几种基本操作，通常包括：</p><h4 id="_3-1-堆化-heapify" tabindex="-1">3.1 <strong>堆化（Heapify）</strong> <a class="header-anchor" href="#_3-1-堆化-heapify" aria-label="Permalink to &quot;3.1 **堆化（Heapify）**&quot;">​</a></h4><p>堆化是一个将数组调整成堆的过程。通过递归或迭代地调整数组中的元素，使得父节点满足堆的性质。</p><ul><li><strong>单向堆化</strong>：将某个子树调整为堆。</li><li><strong>全堆化</strong>：将整个数组调整为堆。</li></ul><h4 id="_3-2-插入-insert" tabindex="-1">3.2 <strong>插入（Insert）</strong> <a class="header-anchor" href="#_3-2-插入-insert" aria-label="Permalink to &quot;3.2 **插入（Insert）**&quot;">​</a></h4><p>插入操作用于向堆中添加一个新元素。新元素通常被添加到堆的最后一个位置，然后通过“上浮”（bubble-up）操作将其调整到正确的位置，确保堆的性质不被破坏。</p><ul><li><strong>步骤</strong>： <ol><li>将新元素添加到堆的末尾。</li><li>将新元素与其父节点比较，若新元素较大（在最大堆中）或较小（在最小堆中），则交换位置，直到堆的性质得到恢复。</li></ol></li></ul><h4 id="_3-3-删除堆顶-extract-max-min" tabindex="-1">3.3 <strong>删除堆顶（Extract Max/Min）</strong> <a class="header-anchor" href="#_3-3-删除堆顶-extract-max-min" aria-label="Permalink to &quot;3.3 **删除堆顶（Extract Max/Min）**&quot;">​</a></h4><p>删除堆顶元素是堆的一个重要操作。在最大堆中，堆顶是最大元素，删除后要保持堆的性质。删除堆顶元素的步骤如下：</p><ul><li><strong>步骤</strong>： <ol><li>将堆顶元素与堆的最后一个元素交换。</li><li>删除堆的最后一个元素（已交换到堆顶）。</li><li>从堆顶开始，通过“下沉”（sink-down）操作将新的堆顶元素恢复为堆。</li></ol></li></ul><h4 id="_3-4-堆排序-heap-sort" tabindex="-1">3.4 <strong>堆排序（Heap Sort）</strong> <a class="header-anchor" href="#_3-4-堆排序-heap-sort" aria-label="Permalink to &quot;3.4 **堆排序（Heap Sort）**&quot;">​</a></h4><p>堆排序是基于堆的排序算法，通过反复提取堆顶元素来排序数组。堆排序的步骤如下：</p><ul><li><strong>步骤</strong>： <ol><li>将输入数组构建成最大堆。</li><li>反复删除堆顶元素（最大元素），将其与当前堆的最后一个元素交换。</li><li>调整堆结构，恢复堆的性质。</li><li>重复此过程，直到堆中只剩一个元素。</li></ol></li></ul><p>堆排序的时间复杂度为 O(nlog⁡n)<em>O</em>(<em>n_log_n</em>)，是一个不稳定的排序算法。</p><h4 id="_3-5-获取堆顶元素-peek" tabindex="-1">3.5 <strong>获取堆顶元素（Peek）</strong> <a class="header-anchor" href="#_3-5-获取堆顶元素-peek" aria-label="Permalink to &quot;3.5 **获取堆顶元素（Peek）**&quot;">​</a></h4><p>获取堆顶元素即访问堆中最大（或最小）元素而不删除它。这个操作时间复杂度为 O(1)<em>O</em>(1)，因为堆顶元素就是堆中最大或最小的元素。</p><h3 id="应用" tabindex="-1"><strong>应用</strong> <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;**应用**&quot;">​</a></h3><p>堆具有许多应用，尤其是在处理优先级队列和排序问题时。</p><h4 id="_4-1-优先队列-priority-queue" tabindex="-1">4.1 <strong>优先队列（Priority Queue）</strong> <a class="header-anchor" href="#_4-1-优先队列-priority-queue" aria-label="Permalink to &quot;4.1 **优先队列（Priority Queue）**&quot;">​</a></h4><p>优先队列是一种抽象数据类型，其中每个元素都关联一个优先级。堆是实现优先队列的一种高效数据结构。</p><ul><li><strong>最大堆</strong>：在优先队列中，具有最高优先级的元素总是位于堆顶。</li><li><strong>最小堆</strong>：在优先队列中，具有最低优先级的元素总是位于堆顶。</li></ul><h4 id="_4-2-堆排序-heap-sort" tabindex="-1">4.2 <strong>堆排序（Heap Sort）</strong> <a class="header-anchor" href="#_4-2-堆排序-heap-sort" aria-label="Permalink to &quot;4.2 **堆排序（Heap Sort）**&quot;">​</a></h4><p>堆排序是一种基于比较的排序算法，时间复杂度为 O(nlog⁡n)<em>O</em>(<em>n_log_n</em>)，不需要额外的内存空间，因此它是一种原地排序。</p><h4 id="_4-3-动态中位数计算" tabindex="-1">4.3 <strong>动态中位数计算</strong> <a class="header-anchor" href="#_4-3-动态中位数计算" aria-label="Permalink to &quot;4.3 **动态中位数计算**&quot;">​</a></h4><p>可以使用两个堆来动态地计算中位数。通常会使用一个最大堆和一个最小堆来分别存储数据的两部分，从而快速获取中位数。</p><h4 id="_4-4-图的算法-例如dijkstra算法" tabindex="-1">4.4 <strong>图的算法（例如Dijkstra算法）</strong> <a class="header-anchor" href="#_4-4-图的算法-例如dijkstra算法" aria-label="Permalink to &quot;4.4 **图的算法（例如Dijkstra算法）**&quot;">​</a></h4><p>在图的算法中，堆（通常是最小堆）用于高效地选择当前最短路径的节点。例如，Dijkstra算法通过使用优先队列来优化最短路径的查找。</p><h3 id="堆的实现" tabindex="-1"><strong>堆的实现</strong> <a class="header-anchor" href="#堆的实现" aria-label="Permalink to &quot;**堆的实现**&quot;">​</a></h3><p><strong>（Python示例）</strong></p><p>在Python中，<code>heapq</code>模块提供了堆的功能，默认实现的是最小堆。</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import heapq</span></span>
<span class="line"><span># 创建一个空堆</span></span>
<span class="line"><span>heap = []</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 向堆中添加元素（堆化操作）</span></span>
<span class="line"><span>heapq.heappush(heap, 20)</span></span>
<span class="line"><span>heapq.heappush(heap, 10)</span></span>
<span class="line"><span>heapq.heappush(heap, 30)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 获取堆顶元素（最小堆，最小元素）</span></span>
<span class="line"><span>print(heap[0])  # 输出 10</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 删除并返回堆顶元素</span></span>
<span class="line"><span>min_element = heapq.heappop(heap)</span></span>
<span class="line"><span>print(min_element)  # 输出 10</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 获取当前堆的堆顶元素</span></span>
<span class="line"><span>print(heap[0])  # 输出 20</span></span></code></pre></div><p>如果需要实现最大堆，可以通过插入负值来模拟：</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import heapq</span></span>
<span class="line"><span># 创建一个空堆</span></span>
<span class="line"><span>max_heap = []</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 向堆中添加元素（模拟最大堆）</span></span>
<span class="line"><span>heapq.heappush(max_heap, -20)</span></span>
<span class="line"><span>heapq.heappush(max_heap, -10)</span></span>
<span class="line"><span>heapq.heappush(max_heap, -30)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 获取堆顶元素（最大堆，最大元素）</span></span>
<span class="line"><span>print(-max_heap[0])  # 输出 30</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 删除并返回堆顶元素</span></span>
<span class="line"><span>max_element = -heapq.heappop(max_heap)</span></span>
<span class="line"><span>print(max_element)  # 输出 30</span></span></code></pre></div><p>堆（Heap）可以使用 JavaScript 来实现</p><h4 id="最大堆的实现" tabindex="-1">最大堆的实现 <a class="header-anchor" href="#最大堆的实现" aria-label="Permalink to &quot;最大堆的实现&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MaxHeap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取父节点索引</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取左子节点索引</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  leftChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取右子节点索引</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  rightChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 判断节点是否是叶子节点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  isLeaf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 堆化操作：将堆的某个部分调整为堆</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  heapify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> largest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">leftChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rightChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 左子节点比父节点大</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[left] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[largest]) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      largest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 右子节点比当前最大的还要大</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[right] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[largest]) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      largest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 如果最大的节点不是父节点，交换并继续堆化</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (largest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[index], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[largest]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[largest], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[index]];</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">heapify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(largest);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 插入一个元素</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将元素插入到堆的末尾</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 向上调整：如果当前元素大于父节点，交换它们</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current)] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[current]) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[current], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current)]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current)], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[current]];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 删除堆顶元素（最大元素）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  extractMax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> max</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将堆顶元素与最后一个元素交换</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除堆顶元素</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 堆化堆顶元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">heapify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取堆顶元素（最大元素）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取堆的大小</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> maxHeap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MaxHeap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">maxHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">maxHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">maxHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">maxHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">maxHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(maxHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 30</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(maxHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extractMax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 30</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(maxHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 20</span></span></code></pre></div><p>要实现最小堆，只需调整条件，使得父节点总是小于或等于其子节点。</p><h4 id="最小堆的实现" tabindex="-1">最小堆的实现 <a class="header-anchor" href="#最小堆的实现" aria-label="Permalink to &quot;最小堆的实现&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MinHeap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  leftChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  rightChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  isLeaf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  heapify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> smallest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">leftChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rightChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[left] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[smallest]) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      smallest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[right] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[smallest]) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      smallest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (smallest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[index], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[smallest]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[smallest], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[index]];</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">heapify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(smallest);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current)] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[current]) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[current], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current)]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current)], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[current]];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  extractMin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> min</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">heapify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> min;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.heap.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> minHeap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MinHeap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">minHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">minHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">minHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">minHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">minHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(minHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(minHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extractMin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(minHeap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 10</span></span></code></pre></div>`,283)]))}const c=a(l,[["render",h]]);export{g as __pageData,c as default};
