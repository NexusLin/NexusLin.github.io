import{_ as n,c as e,o as l,ag as s}from"./chunks/framework.DnwzncJk.js";const h=JSON.parse('{"title":"空间复杂度","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"src/algorithm/03-空间复杂度(Space Complexity).md","filePath":"src/algorithm/03-空间复杂度(Space Complexity).md","lastUpdated":1762248935000}'),i={name:"src/algorithm/03-空间复杂度(Space Complexity).md"};function t(o,a,r,p,c,d){return l(),e("div",null,a[0]||(a[0]=[s(`<h1 id="空间复杂度" tabindex="-1">空间复杂度 <a class="header-anchor" href="#空间复杂度" aria-label="Permalink to &quot;空间复杂度&quot;">​</a></h1><h2 id="空间复杂度-space-complexity" tabindex="-1">空间复杂度（Space Complexity） <a class="header-anchor" href="#空间复杂度-space-complexity" aria-label="Permalink to &quot;空间复杂度（Space Complexity）&quot;">​</a></h2><p>包括</p><ul><li>输入数据所占的空间；</li><li>算法所使用的额外空间；</li><li>递归栈的空间（对于递归算法）</li></ul><h3 id="认识" tabindex="-1"><strong>认识</strong> <a class="header-anchor" href="#认识" aria-label="Permalink to &quot;**认识**&quot;">​</a></h3><p><strong>空间复杂度</strong>是衡量一个算法在运行过程中所需的<strong>内存空间</strong>大小的指标，它描述了随着输入数据规模的增加，算法所需内存空间是如何变化的。与时间复杂度不同，空间复杂度关注的是算法运行时占用的存储空间，而不是执行时间。</p><p>空间复杂度通常是以输入规模 n_n_ 为自变量，表示所需内存的变化情况。</p><p>算法的空间复杂度通常包括两个方面：</p><ol><li><strong>固定空间</strong>：与输入数据的规模无关的空间，通常是算法中使用的常数空间（例如，固定数量的变量）。</li><li><strong>可变空间</strong>：与输入数据规模有关的空间，通常是动态分配的空间（例如，数组、链表、递归栈等）。</li></ol><h3 id="空间复杂度的计算" tabindex="-1">空间复杂度的计算 <a class="header-anchor" href="#空间复杂度的计算" aria-label="Permalink to &quot;空间复杂度的计算&quot;">​</a></h3><p>空间复杂度的计算通常关注以下几个方面：</p><ol><li><strong>输入数据所占空间</strong>：如果算法需要接受输入数据，输入数据本身就占用了内存空间，这部分空间大小通常为 <em>O</em>(<em>n</em>)，其中 <em>n</em> 是输入数据的大小。</li><li><strong>算法内部使用的额外空间</strong>：包括算法运行过程中使用的变量、数组、链表等数据结构所占的内存空间。</li><li><strong>递归调用栈</strong>：如果算法是递归的，则每一次递归调用会占用一定的栈空间，这部分空间在分析递归算法时非常重要</li></ol><h3 id="常见的空间复杂度" tabindex="-1">常见的空间复杂度 <a class="header-anchor" href="#常见的空间复杂度" aria-label="Permalink to &quot;常见的空间复杂度&quot;">​</a></h3><ol><li><strong>O(1)</strong> — 常数空间复杂度 <ul><li>算法在执行过程中需要的内存空间是固定的，不随着输入数据规模的增加而变化。</li><li>例如，简单的变量存储、常数个数的操作等。</li></ul></li><li><strong>O(n)</strong> — 线性空间复杂度 <ul><li>算法所需的内存空间与输入数据的规模成正比。</li><li>例如，遍历一个数组并将其复制到另一个数组。</li></ul></li><li><strong>O(n^2)</strong> — 平方空间复杂度 <ul><li>算法所需的内存空间与输入数据规模的平方成正比。</li><li>例如，二维数组的存储，或者在一些特定的算法中会产生这样的空间复杂度。</li></ul></li><li><strong>O(log n)</strong> — 对数空间复杂度 <ul><li>算法的空间复杂度增长速度较慢，通常与递归算法的深度相关。</li><li>例如，在某些递归算法（如二分查找）的实现中，栈空间的使用可能是对数级别的。</li></ul></li></ol><h3 id="例子分析" tabindex="-1">例子分析 <a class="header-anchor" href="#例子分析" aria-label="Permalink to &quot;例子分析&quot;">​</a></h3><h4 id="例子-1-计算数组元素的和-o-1-空间复杂度" tabindex="-1">例子 1：计算数组元素的和（O(1) 空间复杂度） <a class="header-anchor" href="#例子-1-计算数组元素的和-o-1-空间复杂度" aria-label="Permalink to &quot;例子 1：计算数组元素的和（O(1) 空间复杂度）&quot;">​</a></h4><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>def sum_array(arr):</span></span>
<span class="line"><span>    total = 0  # 常量空间</span></span>
<span class="line"><span>    for num in arr:</span></span>
<span class="line"><span>        total += num</span></span>
<span class="line"><span>    return total</span></span></code></pre></div><ul><li><strong>输入空间</strong>：数组 <code>arr</code> 占用 <em>O</em>(<em>n</em>) 的空间。</li><li><strong>算法空间</strong>：变量 <code>total</code> 是一个常数，所占空间是 <em>O</em>(1)。</li></ul><p><strong>总空间复杂度</strong>：由于算法只使用了固定数量的额外空间，因此该算法的空间复杂度是_O_(1)。</p><h4 id="例子-2-复制一个数组-o-n-空间复杂度" tabindex="-1">例子 2：复制一个数组（O(n) 空间复杂度） <a class="header-anchor" href="#例子-2-复制一个数组-o-n-空间复杂度" aria-label="Permalink to &quot;例子 2：复制一个数组（O(n) 空间复杂度）&quot;">​</a></h4><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>def copy_array(arr):</span></span>
<span class="line"><span>    new_arr = arr.copy()  # 创建一个新的数组</span></span>
<span class="line"><span>    return new_arr</span></span></code></pre></div><ul><li><strong>输入空间</strong>：数组 <code>arr</code> 占用 <em>O</em>(<em>n</em>) 的空间。</li><li><strong>算法空间</strong>：新数组 <code>new_arr</code> 占用 <em>O</em>(<em>n</em>) 的空间。</li></ul><p><strong>总空间复杂度</strong>：算法创建了一个大小与输入数组相同的新数组，因此空间复杂度是 <em>O</em>(<em>n</em>)。</p><h4 id="例子-3-递归计算斐波那契数列-o-n-空间复杂度" tabindex="-1">例子 3：递归计算斐波那契数列（O(n) 空间复杂度） <a class="header-anchor" href="#例子-3-递归计算斐波那契数列-o-n-空间复杂度" aria-label="Permalink to &quot;例子 3：递归计算斐波那契数列（O(n) 空间复杂度）&quot;">​</a></h4><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>def fibonacci(n):</span></span>
<span class="line"><span>    if n &lt;= 1:</span></span>
<span class="line"><span>        return n</span></span>
<span class="line"><span>    return fibonacci(n - 1) + fibonacci(n - 2)</span></span></code></pre></div><ul><li><strong>输入空间</strong>：只有一个整数 <code>n</code>，占用 <em>O</em>(1) 的空间。</li><li><strong>递归栈空间</strong>：每次递归调用会占用栈空间，递归的最大深度为 <em>n</em>，因此递归栈的空间复杂度是 <em>O</em>(<em>n</em>)。</li></ul><p><strong>总空间复杂度</strong>：由于递归调用栈的深度为 <em>n</em>，因此空间复杂度是 <em>O</em>(<em>n</em>)。</p><h3 id="空间复杂度与时间复杂度的关系" tabindex="-1">空间复杂度与时间复杂度的关系 <a class="header-anchor" href="#空间复杂度与时间复杂度的关系" aria-label="Permalink to &quot;空间复杂度与时间复杂度的关系&quot;">​</a></h3><p>在分析算法时，时间复杂度和空间复杂度常常是互相影响的。</p><p>一般来说，某些算法为了提高时间效率可能需要消耗更多的空间，反之，空间有限的情况下也可能牺牲时间效率。</p><ul><li><strong>空间换时间</strong>：例如，使用更多的内存来存储中间结果，减少重复计算（例如，动态规划的备忘录方法）。</li><li><strong>时间换空间</strong>：通过减少内存使用来降低空间消耗，可能需要通过更多的计算来弥补空间的不足。</li></ul>`,31)]))}const g=n(i,[["render",t]]);export{h as __pageData,g as default};
