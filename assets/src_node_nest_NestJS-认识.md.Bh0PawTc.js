import{_ as i,c as a,ag as t,o as n}from"./chunks/framework.Bft4-MjQ.js";const E=JSON.parse('{"title":"NestJS认识","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"src/node/nest/NestJS-认识.md","filePath":"src/node/nest/NestJS-认识.md"}'),e={name:"src/node/nest/NestJS-认识.md"};function l(p,s,h,r,k,d){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="nestjs认识" tabindex="-1">NestJS认识 <a class="header-anchor" href="#nestjs认识" aria-label="Permalink to &quot;NestJS认识&quot;">​</a></h1><p>官网：<a href="https://docs.nestjs.com/" target="_blank" rel="noreferrer">https://docs.nestjs.com/</a></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">https</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//docs.nestjs.com/</span></span></code></pre></div><h2 id="_1、简介" tabindex="-1">1、简介 <a class="header-anchor" href="#_1、简介" aria-label="Permalink to &quot;1、简介&quot;">​</a></h2><p>NestJS 是一个基于 Node.js 构建的框架，主要使用 TypeScript 进行开发，理念是模块化和依赖注入。</p><p>适用性：适用于复杂后端架构、大型的企业级应用、微服务、企业级系统。</p><h2 id="_2、理念" tabindex="-1">2、理念 <a class="header-anchor" href="#_2、理念" aria-label="Permalink to &quot;2、理念&quot;">​</a></h2><p>结合了面向对象编程（OOP）、函数式编程（FP）和函数式响应式编程（FRP）的理念，借鉴了 Angular 的模块化设计思想</p><h2 id="_3、特点" tabindex="-1">3、特点 <a class="header-anchor" href="#_3、特点" aria-label="Permalink to &quot;3、特点&quot;">​</a></h2><h4 id="👉typescript开发-类型安全" tabindex="-1">👉TypeScript开发，类型安全 <a class="header-anchor" href="#👉typescript开发-类型安全" aria-label="Permalink to &quot;👉TypeScript开发，类型安全&quot;">​</a></h4><p>支持 TypeScript，提供强类型检查和接口定义，可以利用 TS的类型检查、装饰器、接口等</p><p>装饰器（Decorator）语法简化路由、中间件、拦截器等配置</p><h4 id="👉模块化架构" tabindex="-1">👉模块化架构 <a class="header-anchor" href="#👉模块化架构" aria-label="Permalink to &quot;👉模块化架构&quot;">​</a></h4><p>模块化独立：应用划分为多个独立的模块，便于扩展和维护</p><p>项目分层：通过<code>@Module</code> 装饰器将代码按功能划分，每个模块封装控制器(<strong>Controller</strong>)、服务(<strong>Service</strong>)、依赖等，适合大型项目分层。</p><p>装饰器和元数据驱动：使用装饰器（如 <code>@Controller</code>、<code>@Injectable</code> 等）来定义路由、控制器、服务等</p><p><strong>依赖注入（DI）</strong>：内建了一个强大的依赖注入系统，允许开发者轻松地管理和注入服务，基于 IoC（控制反转）容器，自动管理类之间的依赖关系，提升代码解耦和可测试性；与 Angular 的依赖注入机制类似，减少了手动管理依赖关系的复杂度</p><h4 id="👉多协议支持" tabindex="-1">👉多协议支持 <a class="header-anchor" href="#👉多协议支持" aria-label="Permalink to &quot;👉多协议支持&quot;">​</a></h4><ul><li><strong>HTTP 服务</strong>：默认集成 Express 或 Fastify，支持不同的 HTTP 服务器框架（Express 或 Fastify），支持 RESTful API 开发，支持各种持久化工具（如 TypeORM、Mongoose 等）</li><li><strong>微服务</strong>：内置 TCP、gRPC、MQTT 等协议，轻松构建分布式系统。</li><li><strong>WebSocket</strong>：通过 <code>@WebSocketGateway</code> 支持实时通信。</li><li><strong>GraphQL</strong>：深度整合 Apollo 或 Mercurius，快速开发 GraphQL API</li><li>可测试性：提供了单元测试和集成测试。通过依赖注入、模块化设计方便测试。</li></ul><h4 id="👉丰富的生态系统" tabindex="-1">👉丰富的生态系统 <a class="header-anchor" href="#👉丰富的生态系统" aria-label="Permalink to &quot;👉丰富的生态系统&quot;">​</a></h4><ul><li><strong>官方工具库</strong>：提供 CLI、认证（Passport）、数据库集成（TypeORM、Prisma）、缓存（Redis）、队列（BullMQ）等模块</li><li><strong>第三方扩展</strong>：活跃的社区支持，可快速集成 Swagger（API 文档）、日志（Winston）、监控（Prometheus）等。</li></ul><h2 id="_4、应用场景以及选择原因" tabindex="-1">4、应用场景以及选择原因 <a class="header-anchor" href="#_4、应用场景以及选择原因" aria-label="Permalink to &quot;4、应用场景以及选择原因&quot;">​</a></h2><h4 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><p>RESTful API 服务：与 TypeORM 或 Mongoose 集成时，能快速创建和管理数据库。</p><p>GraphQL API 服务：对 GraphQL 支持良好，支持自动生成 schema 和解析器。</p><p>微服务架构：对微服务架构的支持良好，适用于构建分布式应用，支持多种通信协议（如 gRPC、WebSockets、Redis 等）。</p><p>实时应用：支持 WebSockets 和其他实时通信机制，适合即时通讯的应用，如聊天应用或实时通知系统。</p><h4 id="选择原因" tabindex="-1">选择原因 <a class="header-anchor" href="#选择原因" aria-label="Permalink to &quot;选择原因&quot;">​</a></h4><p>之前我们的Node后端采取的是Express框架，但是随着项目规模的扩大，项目逐渐逐渐庞大，对比了Koa和NestJS后，选择了NestJS框架,因为Koa我觉得其实跟我的Express差别不大，不如直接采用Express，而TS也是一种趋势，所以选择了NestJS</p><div class="language-JS vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JS</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">express：功能强大，内置中间件和路由，简单，适合中小型项目</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">koa ：轻量级，灵活，需手动管理中间件和路由，适合中小型项目</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NestJS：基于TypeScript，支持模块化、依赖注入和装饰器，组织清晰，适合大型项目</span></span></code></pre></div><p>因此我选择了NestJS框架作为项目升级，它提供了更好的代码组织、模块化和高维护性，内置了依赖注入和装饰器等高级功能，使得代码更加简洁和易读。</p><h2 id="_5、应用示例" tabindex="-1">5、应用示例 <a class="header-anchor" href="#_5、应用示例" aria-label="Permalink to &quot;5、应用示例&quot;">​</a></h2><p>NestJS 应用示例：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Controller, Get } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/common&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Request } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;express&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Controller</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;cats&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CatsController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    findAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;This action returns all cats&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个例子中，<code>@Controller(&#39;cats&#39;)</code> 定义了一个控制器，并且 <code>@Get()</code> 装饰器标记了一个 GET 请求的路由方法</p><p>这里我们简单看看上面部分代码的作用</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Controller, Get, Req } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@nestjs/common&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Request } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;express&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导入NestJS 的几个装饰器和 Request 类型：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Controller：用于映射到一个特定的路由路径</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Get：就是HTTP </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 请求方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Req：获取 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 请求对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Request：express 模块中导入的类型，</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 请求对象的类型，用来进行类型检查</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Controller</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;cats&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">就是我们请求的接口 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`/cats\`</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">然后导出CatsController类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()装饰器将 findAll 方法与 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HTTP</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 请求关联</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 当用户访问 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cats 路由时，调用findAll方法</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() request: Request): string {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;This action returns all cats&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">这里findAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()就是一个比较普通的TS函数，返回我们string类型的数据</span></span></code></pre></div><h2 id="_6、核心组件" tabindex="-1">6、核心组件 <a class="header-anchor" href="#_6、核心组件" aria-label="Permalink to &quot;6、核心组件&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>组件</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>Controller</strong></td><td>处理 HTTP 请求，定义路由和参数解析（类似 MVC 中的控制器）。</td></tr><tr><td><strong>Service</strong></td><td>封装业务逻辑，通过依赖注入供控制器或其他服务调用。</td></tr><tr><td><strong>Middleware</strong></td><td>在请求到达控制器前执行，用于日志、鉴权、数据转换等。</td></tr><tr><td><strong>Interceptor</strong></td><td>拦截请求和响应，实现全局异常处理、数据包装、性能监控等。</td></tr><tr><td><strong>Guard</strong></td><td>路由守卫，控制请求权限（如角色验证）。</td></tr><tr><td><strong>Pipe</strong></td><td>数据验证和转换（如校验请求参数、转换数据类型）。</td></tr></tbody></table>`,39)]))}const c=i(e,[["render",l]]);export{E as __pageData,c as default};
