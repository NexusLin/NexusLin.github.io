import{_ as l,c as e,o as t,ag as i}from"./chunks/framework.DnwzncJk.js";const _=JSON.parse('{"title":"时间复杂度（Time Complexity）","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"src/algorithm/02-时间复杂度(Time Complexity).md","filePath":"src/algorithm/02-时间复杂度(Time Complexity).md","lastUpdated":1762248935000}'),o={name:"src/algorithm/02-时间复杂度(Time Complexity).md"};function a(r,n,s,g,m,p){return t(),e("div",null,n[0]||(n[0]=[i(`<h1 id="时间复杂度-time-complexity" tabindex="-1">时间复杂度（Time Complexity） <a class="header-anchor" href="#时间复杂度-time-complexity" aria-label="Permalink to &quot;时间复杂度（Time Complexity）&quot;">​</a></h1><h2 id="_1、时间复杂度-time-complexity" tabindex="-1"><strong>1、时间</strong>复杂度（Time Complexity） <a class="header-anchor" href="#_1、时间复杂度-time-complexity" aria-label="Permalink to &quot;**1、时间**复杂度（Time Complexity）&quot;">​</a></h2><h3 id="认识时间复杂度" tabindex="-1"><strong>认识时间</strong>复杂度 <a class="header-anchor" href="#认识时间复杂度" aria-label="Permalink to &quot;**认识时间**复杂度&quot;">​</a></h3><p><strong>时间复杂度</strong>是用来衡量算法执行时间的一个指标，它描述了随着输入数据规模的增加，算法的运行时间是如何变化的。通常，时间复杂度是以输入规模 <strong>n</strong> 为自变量，表示算法执行所需时间与数据规模之间的关系。</p><p>时间复杂度的主要目的是分析和比较算法在不同数据规模下的表现，从而帮助开发者选择最适合的算法。</p><h4 id="常见的时间复杂度表示方法-从低到高" tabindex="-1">常见的时间复杂度表示方法（从低到高） <a class="header-anchor" href="#常见的时间复杂度表示方法-从低到高" aria-label="Permalink to &quot;常见的时间复杂度表示方法（从低到高）&quot;">​</a></h4><ol><li><strong>常数时间复杂度</strong> — <em>O</em>(1) <ul><li>表示算法的运行时间是常数，不依赖于输入数据的规模。例如，访问数组中的一个元素。</li></ul></li><li><strong>对数时间复杂度</strong> — <em>O</em>(log_n_) <ul><li>表示算法的运行时间随着输入规模的增大而增长较慢。常见于二分查找等算法中。</li><li>例如，在一个排序好的数组中进行二分查找，时间复杂度为 <em>O</em>(log_n_)。</li></ul></li><li><strong>线性时间复杂度</strong> — <em>O</em>(<em>n</em>) <ul><li>表示算法的运行时间与输入数据规模呈线性关系。例如，遍历一个数组并对每个元素进行处理。</li></ul></li><li><strong>线性对数时间复杂度</strong> — <em>O</em>(<em>n_log_n</em>) <ul><li>表示算法的运行时间是线性时间和对数时间的组合。常见的高效排序算法，如归并排序、快速排序，通常具有 <em>O</em>(<em>n_log_n</em>) 的时间复杂度。</li></ul></li><li><strong>平方时间复杂度</strong> — <em>O</em>(_n_2) <ul><li>表示算法的运行时间与输入数据规模的平方成正比。常见于简单的排序算法（如冒泡排序、选择排序）或嵌套循环的算法。</li><li>例如，一个双重循环遍历二维数组的操作，时间复杂度通常为 <em>O</em>(_n_2)。</li></ul></li><li><strong>立方时间复杂度</strong> — <em>O</em>(_n_3) <ul><li>代表算法的运行时间与输入规模的立方成正比，常见于一些复杂的嵌套三重循环算法。</li></ul></li><li><strong>指数时间复杂度</strong> — <em>O</em>(2_n_) <ul><li>表示算法的运行时间随着输入数据规模的增加呈指数增长，通常表示算法效率较低。例如，穷举法解某些问题时可能具有指数时间复杂度。</li></ul></li><li><strong>阶乘时间复杂度</strong> — <em>O</em>(<em>n</em>!) <ul><li>这是时间复杂度中增长最快的一类，常见于某些解排列组合问题的算法。例如，旅行商问题的暴力解法可能具有_O_(<em>n</em>!) 的时间复杂度。</li></ul></li></ol><h4 id="具体示例" tabindex="-1">具体示例 <a class="header-anchor" href="#具体示例" aria-label="Permalink to &quot;具体示例&quot;">​</a></h4><ul><li><strong>O(1)</strong>：获取数组某个元素的值（通过索引访问）；</li><li><strong>O(n)</strong>：遍历一个数组并输出每个元素；</li><li><strong>O(n^2)</strong>：冒泡排序；</li><li><strong>O(n \\log n)</strong>：快速排序、归并排序；</li><li><strong>O(2^n)</strong>：穷举所有子集的问题（例如斐波那契数列的递归解法）</li></ul><h3 id="分析算法的时间复杂度" tabindex="-1">分析算法的时间复杂度 <a class="header-anchor" href="#分析算法的时间复杂度" aria-label="Permalink to &quot;分析算法的时间复杂度&quot;">​</a></h3><ol><li><strong>最内层循环的次数</strong>：分析每个循环的执行次数。嵌套的循环通常会影响时间复杂度。</li><li><strong>递归关系</strong>：对于递归算法，通常需要使用递归树或者递推式来分析时间复杂度。</li><li><strong>基本操作的次数</strong>：算法中的基本操作（如比较、赋值等）执行的次数也直接影响时间复杂度。</li></ol><h4 id="例子-冒泡排序" tabindex="-1">例子：冒泡排序 <a class="header-anchor" href="#例子-冒泡排序" aria-label="Permalink to &quot;例子：冒泡排序&quot;">​</a></h4><p>冒泡排序的算法每次比较相邻两个元素并交换位置，直到所有元素都排好序。假设排序的数组有 <strong>n</strong> 个元素：</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pythonCopy Codefor i in range(n):</span></span>
<span class="line"><span>    for j in range(n - i - 1):</span></span>
<span class="line"><span>        if array[j] &gt; array[j + 1]:</span></span>
<span class="line"><span>            array[j], array[j + 1] = array[j + 1], array[j]</span></span></code></pre></div><ul><li>外层循环：执行 <strong>n</strong> 次；</li><li>内层循环：执行 <strong>n - 1</strong> 次，接着是 <strong>n - 2</strong> 次，以此类推。</li></ul><p>所以总的操作次数是：(n−1)+(n−2)+...+1(<em>n</em>−1)+(<em>n</em>−2)+...+1，这个和是 n(n−1)/2，即 <em>O</em>(_n_2)。</p><h3 id="时间复杂度高低的判断标准" tabindex="-1">时间复杂度高低的判断标准 <a class="header-anchor" href="#时间复杂度高低的判断标准" aria-label="Permalink to &quot;时间复杂度高低的判断标准&quot;">​</a></h3><ul><li><strong>O(1)</strong> 复杂度是最优的，表示执行时间不会随输入规模变化，始终固定。</li><li><strong>O(log n)</strong> 和 <strong>O(n)</strong> 复杂度的算法较高效，特别是在处理大规模数据时。</li><li><strong>O(n log n)</strong> 是很多高效算法（如排序算法）常见的时间复杂度，通常算作比较优秀的表现。</li><li><strong>O(n²)</strong> 及更高复杂度的算法，如 <strong>O(n³)</strong> 或 <strong>O(2^n)</strong>，通常会在数据量较大时变得非常慢，因此需要优化。</li><li><strong>O(2^n)</strong> 和 <strong>O(n!)</strong> 复杂度通常是非常不理想的，尤其是在输入规模稍大时，算法效率极低。</li></ul>`,18)]))}const u=l(o,[["render",a]]);export{_ as __pageData,u as default};
