import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.CqxIsSM8.js";const o=JSON.parse('{"title":"基本类型之数值类型","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"src/rust/02-基本类型之数值类型.md","filePath":"src/rust/02-基本类型之数值类型.md","lastUpdated":1751018573000}'),h={name:"src/rust/02-基本类型之数值类型.md"};function l(p,s,e,k,d,r){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="基本类型之数值类型" tabindex="-1">基本类型之数值类型 <a class="header-anchor" href="#基本类型之数值类型" aria-label="Permalink to &quot;基本类型之数值类型&quot;">​</a></h1><h2 id="rust基本类型" tabindex="-1">Rust基本类型 <a class="header-anchor" href="#rust基本类型" aria-label="Permalink to &quot;Rust基本类型&quot;">​</a></h2><p>Rust 每个值都有确切的数据类型，大致可以分为两类（基本类型和复合类型）</p><h4 id="🍎基本类型" tabindex="-1">🍎基本类型 <a class="header-anchor" href="#🍎基本类型" aria-label="Permalink to &quot;🍎基本类型&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">数值类型：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  有符号整数</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i8, i16, i32, i64, isize)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  无符号整数</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (u8, u16, u32, u64, usize) </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  浮点数</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f32, f64)、以及有理数、复数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">字符串：字符串字面量和字符串切片 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">str</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">布尔类型：</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 和 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">字符类型：表示单个 Unicode 字符，存储为 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 个字节</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">单元类型：</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">即</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () ，</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">其唯一的值也是</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ()</span></span></code></pre></div><h4 id="🍎类型推导与标注" tabindex="-1">🍎类型推导与标注 <a class="header-anchor" href="#🍎类型推导与标注" aria-label="Permalink to &quot;🍎类型推导与标注&quot;">​</a></h4><p>Rust也包含有类型推导，跟其他语言差不多。就是推导数据类型。</p><h2 id="数值类型" tabindex="-1">数值类型 <a class="header-anchor" href="#数值类型" aria-label="Permalink to &quot;数值类型&quot;">​</a></h2><h3 id="👉认识无符号数和有符号数" tabindex="-1">👉认识无符号数和有符号数 <a class="header-anchor" href="#👉认识无符号数和有符号数" aria-label="Permalink to &quot;👉认识无符号数和有符号数&quot;">​</a></h3><p>无符号数和有符号数是计算机中表示整数的两种方式，主要区别在于是否允许表示负数</p><h4 id="🍎-有符号数-signed-integer" tabindex="-1">🍎 有符号数（Signed Integer） <a class="header-anchor" href="#🍎-有符号数-signed-integer" aria-label="Permalink to &quot;🍎 有符号数（Signed Integer）&quot;">​</a></h4><p>有符号数（正数、零和负数的整数）。计算机使用一个额外的位（通常是最高位）来表示符号。常见的表示方式有<strong>补码</strong>表示法。</p><ul><li><strong>补码表示法</strong>：最高位（最左边的一位）用来表示符号。0表示正数，1表示负数。 <ul><li>例如，8位有符号数：<code>11111111</code> 表示 -1，<code>00000001</code> 表示 +1。</li><li>通过补码方式，可以轻松进行加减运算。</li></ul></li></ul><h4 id="🍎无符号数-unsigned-integer" tabindex="-1">🍎无符号数（Unsigned Integer） <a class="header-anchor" href="#🍎无符号数-unsigned-integer" aria-label="Permalink to &quot;🍎无符号数（Unsigned Integer）&quot;">​</a></h4><p>无符号数（正数和零），没有符号位，因此所有位都用来表示数值大小。因为没有符号位，所以它的值域比有符号数多一倍。</p><ul><li>例如，8位无符号数的范围是从 0 到 255（即 0 到 2<sup>8</sup>−1）</li><li>无符号数的表示只能是正整数和零，无法表示负数</li></ul><h4 id="🍎举例说明" tabindex="-1">🍎举例说明： <a class="header-anchor" href="#🍎举例说明" aria-label="Permalink to &quot;🍎举例说明：&quot;">​</a></h4><ul><li><strong>8位有符号数</strong>：表示的范围是 -128 到 +127。</li><li><strong>8位无符号数</strong>：表示的范围是 0 到 255。</li></ul><h3 id="👉整数类型" tabindex="-1">👉整数类型 <a class="header-anchor" href="#👉整数类型" aria-label="Permalink to &quot;👉整数类型&quot;">​</a></h3><p>rust之中的整数可以概括为（有无符号 + 类型大小(位数)）</p><p>Rust 整型默认使用 <code>let i = 1</code>，那 <code>i</code> 就是 <code>i32</code> 类型，该类型也往往是性能最好的。</p><p>表示方法：没有小数部分的数字 <code>i32</code> 类型表示有符号的 32 位整数</p><p><code>i</code>代表有符号（英文单词 <code>_integer_</code> 缩写）</p><p><code>u</code>代表无符号 （英文单词 unsigned 缩写）</p><h4 id="🍎内置的整数类型" tabindex="-1">🍎内置的整数类型 <a class="header-anchor" href="#🍎内置的整数类型" aria-label="Permalink to &quot;🍎内置的整数类型&quot;">​</a></h4><table tabindex="0"><thead><tr><th>长度</th><th>有符号类型</th><th>无符号类型</th></tr></thead><tbody><tr><td>8 位</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16 位</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32 位</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64 位</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128 位</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>视架构而定</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><h4 id="🍎整型溢出" tabindex="-1">🍎整型溢出 <a class="header-anchor" href="#🍎整型溢出" aria-label="Permalink to &quot;🍎整型溢出&quot;">​</a></h4><p>假设有一个 u8 ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生整型溢出（也就是当一个值超出它的整数类型的最大范围时会发生）</p><ul><li>判定规则</li></ul><p>当在 debug 模式编译时，Rust 会检查整型溢出，存在问题则使程序在编译时 <em>panic</em>(崩溃,Rust 使用这个术语来表明程序因错误而退出)</p><p>发生溢出以后，值会变成这个整型的最小值，遵循的是补码循环溢出（<em>two’s complement wrapping</em>）的规则</p><p>我们可以写一段代码进行检验</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fn </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 定义一个 u8 类型的变量，并赋予其最大值 255</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_u8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> u8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;最大无符号 8 位整数值: {}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, max_u8);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将变量加 1，导致溢出</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> overflow_u8 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> max_u8.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wrapping_add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;溢出后的值: {}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, overflow_u8);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">最大无符号 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 位整数值</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">溢出后的值</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span></code></pre></div><ul><li>如何跳过校验呢</li></ul><p>使用 <code>--release</code> 参数进行 release 模式构建时，Rust <strong>不</strong>检测溢出。</p><h3 id="👉浮点类型" tabindex="-1">👉浮点类型 <a class="header-anchor" href="#👉浮点类型" aria-label="Permalink to &quot;👉浮点类型&quot;">​</a></h3><p>Rust 中浮点类型 分为<code>f32</code> 和 <code>f64</code>两种，默认为<code>f64</code>，根据 <code>IEEE-754</code> 标准实现</p><table tabindex="0"><thead><tr><th>特性</th><th><code>f32</code></th><th><code>f64</code>(默认为这个)</th></tr></thead><tbody><tr><td><strong>大小</strong></td><td>32 位</td><td>64 位</td></tr><tr><td><strong>精度</strong></td><td>单精度浮点数，精度约为 7 位有效数字</td><td>双精度浮点数，精度约为 15 位有效数字</td></tr><tr><td><strong>默认类型</strong></td><td>否</td><td>是</td></tr><tr><td><strong>范围</strong></td><td>大约 ±1.5 × 10^−45 到 ±3.4 × 10^38</td><td>大约 ±5.0 × 10^−324 到 ±1.8 × 10^308</td></tr><tr><td><strong>使用场景</strong></td><td>当对内存占用要求较高时（例如嵌入式系统）</td><td>当需要更高精度时，例如科学计算</td></tr><tr><td><strong>性能</strong></td><td>在某些 CPU 上速度较快，但精度较低</td><td>在现代 CPU 上与 <code>f32</code><br> 性能相似，但提供更高精度</td></tr><tr><td><strong>表示方式</strong></td><td>采用 IEEE 754 单精度浮点数标准</td><td>采用 IEEE 754 双精度浮点数标准</td></tr></tbody></table><h4 id="🍎浮点类型数字" tabindex="-1">🍎浮点类型数字 <a class="header-anchor" href="#🍎浮点类型数字" aria-label="Permalink to &quot;🍎浮点类型数字&quot;">​</a></h4><p>两种基本类型： <code>f32</code> 和 <code>f64</code></p><p>默认浮点类型是 <code>f64</code></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fn </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// f64</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// f32</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="🍎浮点数陷阱" tabindex="-1">🍎浮点数陷阱 <a class="header-anchor" href="#🍎浮点数陷阱" aria-label="Permalink to &quot;🍎浮点数陷阱&quot;">​</a></h4><h4 id="🍎nan" tabindex="-1">🍎NaN <a class="header-anchor" href="#🍎nan" aria-label="Permalink to &quot;🍎NaN&quot;">​</a></h4><p>Rust 的浮点数类型使用 <code>NaN</code> (not a number) 来处理数学上未定义的结果</p><h3 id="👉数字运算" tabindex="-1">👉数字运算 <a class="header-anchor" href="#👉数字运算" aria-label="Permalink to &quot;👉数字运算&quot;">​</a></h3><p>Rust 支持所有数字类型的基本数学运算，加减乘除如下</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fn </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 加法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 减法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> difference </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 95.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 乘法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> product </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 除法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> quotient </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 56.7</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 32.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 求余</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> remainder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 43</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="👉位运算" tabindex="-1">👉位运算 <a class="header-anchor" href="#👉位运算" aria-label="Permalink to &quot;👉位运算&quot;">​</a></h3><p>Rust 的位运算如下：</p><table tabindex="0"><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp; 位与</td><td>相同位置均为1时则为1，否则为0</td></tr><tr><td></td><td>位或</td></tr><tr><td>^ 异或</td><td>相同位置不相同则为1，相同则为0</td></tr><tr><td>! 位非</td><td>把位中的0和1相互取反，即0置为1，1置为0</td></tr><tr><td>&lt;&lt; 左移</td><td>所有位向左移动指定位数，右位补0</td></tr><tr><td>&gt;&gt; 右移</td><td>所有位向右移动指定位数，带符号移动（正数补0，负数补1）</td></tr></tbody></table><h3 id="👉序列-range" tabindex="-1">👉序列(Range) <a class="header-anchor" href="#👉序列-range" aria-label="Permalink to &quot;👉序列(Range)&quot;">​</a></h3><p>Rust 提供了<code>序列(Range)</code>方式用来生成连续的数值</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1..5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，生成从 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 到 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的连续数字，不包含 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，生成从 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 到 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 的连续数字，包含 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span></span></code></pre></div><p>常用于循环中：</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//数字</span></span>
<span class="line"><span>for i in 1..=5 {</span></span>
<span class="line"><span>    println!(&quot;{}&quot;,i);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 最终程序输出</span></span>
<span class="line"><span>1</span></span>
<span class="line"><span>2</span></span>
<span class="line"><span>3</span></span>
<span class="line"><span>4</span></span>
<span class="line"><span>5</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//字符 </span></span>
<span class="line"><span>for i in &#39;a&#39;..=&#39;z&#39; {</span></span>
<span class="line"><span>    println!(&quot;{}&quot;,i);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>需要注意的是：<code>序列只允许用于数字或字符类型</code>因为它们可以连续起来。其实思考一下，弄个汉字，完全不知道一个汉字背后应该放个啥。</p><p>编译器在编译期同时检查该序列是否为空</p><h3 id="👉as类型转换" tabindex="-1">👉As类型转换 <a class="header-anchor" href="#👉as类型转换" aria-label="Permalink to &quot;👉As类型转换&quot;">​</a></h3><p>As 来完成一个类型到另一个类型的转换，这里有点类似TS</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fn </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i_terger</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">i32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f_terger</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">f64</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i_terger </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;i_terger is: {}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, i_terger);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;f_terger is: {}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, f_terger);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i_terger </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f_terger </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span></code></pre></div><h3 id="👉有理数和复数" tabindex="-1">👉有理数和复数 <a class="header-anchor" href="#👉有理数和复数" aria-label="Permalink to &quot;👉有理数和复数&quot;">​</a></h3><p>Rust 中处理有理数（Rational Numbers）和复数（Complex Numbers）并没有内建的类型</p><p>我们可以使用 <code>num</code> 外部库来处理有理数和复数，它提供了 <code>Rational</code> 和 <code>Complex</code> 类型</p><p>这里后续进行补充完善</p>`,65)]))}const g=i(h,[["render",l]]);export{o as __pageData,g as default};
