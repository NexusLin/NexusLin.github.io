import{_ as s,c as t,ag as e,o as i}from"./chunks/framework.Bft4-MjQ.js";const k=JSON.parse('{"title":"watchEffect","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"src/vue/api/vue3-watchEffect.md","filePath":"src/vue/api/vue3-watchEffect.md"}'),n={name:"src/vue/api/vue3-watchEffect.md"};function c(p,a,h,l,d,r){return i(),t("div",null,a[0]||(a[0]=[e(`<h1 id="watcheffect" tabindex="-1">watchEffect <a class="header-anchor" href="#watcheffect" aria-label="Permalink to &quot;watchEffect&quot;">​</a></h1><p>☞ 介绍</p><p>先来看看官方文档的介绍：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。</p><p>这么一看，这个函数的作用和 <code>watch</code> 函数有点相似，都是用来监听响应式数据的变化，并在变化时执行一些操作。但是 <code>watchEffect</code> 和 <code>watch</code> 肯定是有区别的,接下来我们先看看 <code>watchEffect</code> 的用法。</p><p>☞ 语法</p><p>整个语法部分非常简单：</p><div class="language-JS vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JS</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { watchEffect } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watchEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 响应式追踪</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div>`,7)]))}const f=s(n,[["render",c]]);export{k as __pageData,f as default};
