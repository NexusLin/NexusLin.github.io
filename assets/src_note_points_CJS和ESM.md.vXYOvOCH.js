import{_ as e,c as a,o as t,ag as s}from"./chunks/framework.CqxIsSM8.js";const u=JSON.parse('{"title":"CommonJS和ES Modules篇","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"src/note/points/CJS和ESM.md","filePath":"src/note/points/CJS和ESM.md","lastUpdated":1754473957000}'),n={name:"src/note/points/CJS和ESM.md"};function d(p,o,i,r,l,c){return t(),a("div",null,o[0]||(o[0]=[s(`<h1 id="commonjs和es-modules篇" tabindex="-1">CommonJS和ES Modules篇 <a class="header-anchor" href="#commonjs和es-modules篇" aria-label="Permalink to &quot;CommonJS和ES Modules篇&quot;">​</a></h1><p>CJS\\AMD\\CMD\\UMD\\ES Modules</p><h2 id="_1、认识" tabindex="-1">1、认识 <a class="header-anchor" href="#_1、认识" aria-label="Permalink to &quot;1、认识&quot;">​</a></h2><p><strong>CommonJS（CJS）</strong> 和 <strong>ES Modules（ESM）</strong> 是JS的两种模块化系统。在模块导入、导出、加载机制、使用场景等方面存在显著的区别。</p><h3 id="🍎模块化发展历程" tabindex="-1">🍎模块化发展历程 <a class="header-anchor" href="#🍎模块化发展历程" aria-label="Permalink to &quot;🍎模块化发展历程&quot;">​</a></h3><p>2009 =&gt; CommonJS 诞生，被Node.js作为一个标准开始制定使用，作为默认的模块化系统</p><p><strong>2010年</strong>=&gt;<code>CommonJS</code> 模块规范正式发布<br> 2015 =&gt; ES6 Modules 标准化，同年也是ECMAScript 6（即 ES6）规范的发布<br> 2020 =&gt; Node.js 13+ 正式支持 ES Modules<br> 2023 =&gt; 90% 的新项目首选 ES Modules</p><h3 id="🍎使用场景以及支持的环境" tabindex="-1">🍎使用场景以及支持的环境 <a class="header-anchor" href="#🍎使用场景以及支持的环境" aria-label="Permalink to &quot;🍎使用场景以及支持的环境&quot;">​</a></h3><p><strong>CommonJS</strong></p><p>主要用于 <strong>Node.js</strong> 环境，虽然在浏览器中能通过工具（如 Webpack、Browserify）进行打包，但原生不支持。</p><p><strong>ES Modules</strong></p><p>浏览器和 Node.js 都支持 ES Modules，且现代浏览器普遍支持 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签。</p><h3 id="🍎语法区别" tabindex="-1">🍎语法区别 <a class="header-anchor" href="#🍎语法区别" aria-label="Permalink to &quot;🍎语法区别&quot;">​</a></h3><h4 id="cjs-commonjs" tabindex="-1">CJS(CommonJS) <a class="header-anchor" href="#cjs-commonjs" aria-label="Permalink to &quot;CJS(CommonJS)&quot;">​</a></h4><p>CommonJS 是一种同步加载模块的规范，主要用于服务器端的 JavaScript（比如 Node.js）。</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 导入模块</span></span>
<span class="line"><span>const module = require(&#39;xxx&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>//导出模块</span></span>
<span class="line"><span>module.exports = { xxx };</span></span></code></pre></div><p>或者使用下面的写法</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>exports.xxxFunction = function() { </span></span>
<span class="line"><span>    xxx</span></span>
<span class="line"><span>};</span></span></code></pre></div><h4 id="esm-es-modules" tabindex="-1">ESM(ES Modules) <a class="header-anchor" href="#esm-es-modules" aria-label="Permalink to &quot;ESM(ES Modules)&quot;">​</a></h4><p>ES Modules是 JavaScript 官方标准（ECMAScript）的一部分，旨在在浏览器和服务器端（如 Node.js）中提供一致的模块化支持。</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 导入模块 方式一 (推荐使用)</span></span>
<span class="line"><span>import { someFunction } from &#39;./module-name&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 导入模块 方式二</span></span>
<span class="line"><span>import * as module from &#39;./xxx&#39;;</span></span></code></pre></div><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 导出模块 方式一(推荐使用)</span></span>
<span class="line"><span>export const someFunction = () =&gt; { };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 导出模块 方式二</span></span>
<span class="line"><span>export default function() {  };</span></span></code></pre></div><h4 id="amd-asynchronous-module-definition" tabindex="-1">AMD (Asynchronous Module Definition) <a class="header-anchor" href="#amd-asynchronous-module-definition" aria-label="Permalink to &quot;AMD (Asynchronous Module Definition)&quot;">​</a></h4><p>2009年</p><p>AMD 是一种异步加载模块的规范，主要用于浏览器环境。它允许开发者在模块加载完成之前执行其他操作，从而提高页面加载速度。</p><p>在前端应运而生，对大型应用的加载性能优化有帮助</p><h4 id="cmd-common-module-definition" tabindex="-1">CMD (Common Module Definition) <a class="header-anchor" href="#cmd-common-module-definition" aria-label="Permalink to &quot;CMD (Common Module Definition)&quot;">​</a></h4><p>2010年</p><p>由阿里巴巴的 <code>SeaJS</code> 提出，针对前端开发中的模块化问题，特别注重延迟加载和按需加载，与 AMD 类似，但更注重模块加载时依赖的延迟解析。</p><h4 id="umd-universal-module-definition" tabindex="-1">UMD (Universal Module Definition) <a class="header-anchor" href="#umd-universal-module-definition" aria-label="Permalink to &quot;UMD (Universal Module Definition)&quot;">​</a></h4><p>2011年</p><p>UMD 结合了 CommonJS 和 AMD 的特点，能够在浏览器和 Node.js 环境中同时使用。</p><h2 id="_2、commonjs和es-modules发展及解决问题" tabindex="-1">2、CommonJS和ES Modules发展及解决问题 <a class="header-anchor" href="#_2、commonjs和es-modules发展及解决问题" aria-label="Permalink to &quot;2、CommonJS和ES Modules发展及解决问题&quot;">​</a></h2><p>2009以前</p><p>JavaScript 初期，浏览器环境中的 JavaScript 程序通常是单一的、全局作用域的，所有代码都混合在一起。程序复杂以后，开发者的代码急切的需要一种模块化机制来组织代码、提高可重用性和可维护性</p><p>为了应对 Node.js 环境中对模块的需求，Node.js（2009年发布）使用了<code>CommonJS</code>作为默认的模块化系统，Node.js制定标准CommonJS，2010年<code>CommonJS</code>模块正式发布。</p><p>CommonJS 模块是同步加载的，使得它适用于服务器端应用。</p><p>但CommonJS 模块是在运行时加载的，导致无法进行静态分析，像 Tree Shaking 和 代码分割（Code Splitting） 这样的优化无法在打包时进行</p><p>2015年ECMAScript 6（即 ES6）规范发布，内建模块系统<code>ES Modules（ESM）</code>，ES6 Modules 彻底标准化。<code>ESM</code> 的静态结构使得 JavaScript 引擎能够在编译时进行优化，Tree Shaking 和 代码分割（Code Splitting）信手拈来，并且**跨平台支持。**2020年Node.js 13+ 全力支持 ES Modules，ESM成为主流。</p><h2 id="_3、commonjs和esm的区别和不同" tabindex="-1">3、CommonJS和ESM的区别和不同 <a class="header-anchor" href="#_3、commonjs和esm的区别和不同" aria-label="Permalink to &quot;3、CommonJS和ESM的区别和不同&quot;">​</a></h2><h3 id="🍎加载方式的区别" tabindex="-1">🍎加载方式的区别 <a class="header-anchor" href="#🍎加载方式的区别" aria-label="Permalink to &quot;🍎加载方式的区别&quot;">​</a></h3><p>CommonJS同步加载，当执行 <code>require()</code> 时，Node.js 会立即加载并执行模块代码。加载后的模块被缓存，并且返回模块的导出对象。适合于服务器端的同步需求。</p><p>CommonJS不能在浏览器中直接使用（直到现代浏览器支持 ES Modules）</p><p>ES Modules是异步加载 的，适用于浏览器和服务器端</p><p>支持静态分析，编译器和打包工具可以提前分析模块的依赖关系</p><p>支持动态导入，使用 <code>import()</code> 函数异步加载模块</p><p>涉及到按需加载和优化性能时非常好用</p><h3 id="🍎模块的解析和执行时机" tabindex="-1">🍎模块的解析和执行时机 <a class="header-anchor" href="#🍎模块的解析和执行时机" aria-label="Permalink to &quot;🍎模块的解析和执行时机&quot;">​</a></h3><p>CommonJS模块代码立即执行，当 <code>require()</code> 被调用时，模块会立即被加载并执行一次</p><p>ESModules模块代码按需加载，模块的导入是静态绑定，导入的值是模块首次执行时的值，且不再变化</p><h3 id="🍎默认导出" tabindex="-1">🍎默认导出 <a class="header-anchor" href="#🍎默认导出" aria-label="Permalink to &quot;🍎默认导出&quot;">​</a></h3><p>CommonJS使用 <code>module.exports</code> 进行导出，默认导出的模块对象不需要特别标注</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// CommonJS 导出</span></span>
<span class="line"><span>module.exports = function() { /* ... */ };</span></span></code></pre></div><p>ES Modules支持 <code>default</code> 导出，直接导出一个默认值</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// ES Modules 导出</span></span>
<span class="line"><span>export default function() { /* ... */ };</span></span></code></pre></div><h3 id="🍎模块缓存" tabindex="-1">🍎模块缓存 <a class="header-anchor" href="#🍎模块缓存" aria-label="Permalink to &quot;🍎模块缓存&quot;">​</a></h3><p>CommonJS在第一次被 <code>require()</code> 时会被加载并缓存，后续的 <code>require()</code> 调用将直接返回缓存的模块对象</p><p>ES Modules也会被缓存，但每个模块导入时，它是只读的，按照静态结构导出，不会改变</p><h3 id="🍎在-node-js的支持" tabindex="-1">🍎在 <code>Node.js</code>的支持 <a class="header-anchor" href="#🍎在-node-js的支持" aria-label="Permalink to &quot;🍎在 \`Node.js\`的支持&quot;">​</a></h3><h4 id="commonjs" tabindex="-1">CommonJS <a class="header-anchor" href="#commonjs" aria-label="Permalink to &quot;CommonJS&quot;">​</a></h4><p>Node.js 原生支持 CommonJS，从 Node.js 的最早版本开始就被广泛使用</p><h4 id="es-modules" tabindex="-1">ES Modules <a class="header-anchor" href="#es-modules" aria-label="Permalink to &quot;ES Modules&quot;">​</a></h4><p>🛹<code>v12.x</code> 开始初步实验性支持</p><p>Node.js开始引入对 ES Modules 的支持</p><p>🛹<code>Node.js14</code>实验性支持阶段</p><p>ESM逐渐稳定和广泛，引入ESM的实验性支持</p><p>使用<code>.mjs</code>文件扩展名或通过<code>&quot;type&quot;: &quot;module&quot;</code>配置项启用对ESM的支持，启用ESM模块支持</p><p>🛹<code>Node.js 16.x</code></p><p>ESM 成为稳定功能，支持 .js 文件和 .mjs 文件，项目中可以全局启用</p><p>🛹<code>Node.js 18.x和20.x</code></p><p>增强ESM 支持，进一步优化与 CJS 的互操作性</p><p>🛹 未来</p><p>ESM是大势所趋</p><h3 id="🍎循环依赖处理" tabindex="-1">🍎循环依赖处理 <a class="header-anchor" href="#🍎循环依赖处理" aria-label="Permalink to &quot;🍎循环依赖处理&quot;">​</a></h3><p>CommonJS</p><p>CommonJS 处理循环依赖时，返回的是已加载的模块的部分内容，这可能导致循环依赖的一些问题。</p><p>ES Modules</p><p>ESM 通过 &quot;死锁&quot; 模式来处理循环依赖，确保模块的内容始终是稳定和一致的。</p><h2 id="_4、两者对比" tabindex="-1">4、两者对比 <a class="header-anchor" href="#_4、两者对比" aria-label="Permalink to &quot;4、两者对比&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th><strong>CommonJS</strong></th><th><strong>ESModule (ESM)</strong></th></tr></thead><tbody><tr><td>加载方式</td><td>同步加载</td><td>异步加载（支持动态导入）<br>支持懒加载</td></tr><tr><td><strong>模块语法</strong></td><td><code>require()</code><br><code>module.exports</code></td><td><code>import</code><br><code>export</code></td></tr><tr><td><strong>跨平台兼容性</strong></td><td>主要适用于 Node.js，浏览器需使用工具支持</td><td>浏览器和 Node.js 都支持</td></tr><tr><td>导出类型</td><td>无法区分默认导出与命名导出</td><td>支持默认导出<br>（<code>export default</code>）</td></tr><tr><td>模块缓存</td><td>会缓存已加载模块</td><td>缓存且模块是只读的</td></tr><tr><td>循环依赖处理</td><td>可能会返回部分模块</td><td>更好地处理循环依赖</td></tr><tr><td>适用</td><td>服务器端的同步加载和模块化</td><td>现代的前端开发和浏览器环境</td></tr><tr><td>优点</td><td><strong>兼容性良好、同步加载、简单易用</strong></td><td>支持异步加载、静态分析和更清晰的模块结构</td></tr><tr><td><strong>静态分析和优化</strong></td><td>无法进行静态分析，不能进行优化</td><td>支持静态分析<br>支持<strong>Tree Shaking</strong>（去除未使用的代码）<br>代码分割（Code Splitting）</td></tr><tr><td><strong>性能</strong></td><td>较为适合服务器端，浏览器中性能较差</td><td>支持懒加载和优化，适用于浏览器和 Node.js</td></tr><tr><td><strong>生态系统</strong></td><td>已有庞大的生态系统，几乎所有 Node.js 包都使用</td><td>生态系统逐步成长，尤其是在现代 JavaScript 项目中</td></tr><tr><td><strong>互操作性</strong></td><td>与其他模块系统兼容良好</td><td>与 CommonJS 存在兼容性问题</td></tr><tr><td><strong>支持的 Node.js 版本</strong></td><td>所有 Node.js 版本均支持</td><td>Node.js 从 v12 开始全面支持 ESM</td></tr><tr><td><strong>错误处理与模块执行顺序</strong></td><td>顺序执行，无异步问题</td><td>模块执行有异步加载的潜在影响</td></tr><tr><td><strong>学习曲线</strong></td><td>简单，易于上手</td><td>对于老旧项目的迁移可能需要更多工作</td></tr><tr><td><strong>顶层</strong><code>await</code><strong>支持</strong></td><td>不支持</td><td>支持</td></tr></tbody></table><h2 id="_5、衍生" tabindex="-1">5、衍生 <a class="header-anchor" href="#_5、衍生" aria-label="Permalink to &quot;5、衍生&quot;">​</a></h2><p>CJS\\AMD\\CMD\\UMD\\ES Modules</p>`,82)]))}const h=e(n,[["render",d]]);export{u as __pageData,h as default};
